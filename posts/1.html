<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>Page 1 - Zero Sky</title>
    <meta name="keywords" content="C&#43;&#43; Golang React Python Vim"/>
    <meta name="description" content="PuGo is a Simple Static Site Generator"/>
    <link rel="stylesheet" href="/css/bootstrap.min.css"/>
    <link rel="stylesheet" href="/css/prism.css"/>
    <link rel="stylesheet" href="/css/style.css"/>
</head>
<body class="post-list" data-perma="post-page-1">
<header id="header">
    <div class="container">
        <div class="header clearfix">
            <nav id="site-nav">
                <ul class="nav nav-inverse nav-pills pull-right">
                    <li role="presentation" class="">
                        <a href="/" >Home
                        </a>
                    </li>
                    <li role="presentation" class="">
                        <a href="/archive.html" >Archive
                        </a>
                    </li>
                    <li role="presentation" class="">
                        <a href="/about.html" >About
                        </a>
                    </li>
                    <li role="presentation" class="">
                        <a href="https://github.com/netdigger/blog"  target="_blank" >Source
                        </a>
                    </li>
                </ul>
            </nav>
            <h3 id="site-title">
                <a href="/">Zero Sky <sup>Notes of Programmer</sup></a>
            </h3>
        </div>
    </div>
</header>

<section id="main">
    <div class="container">
        <div id="article-list">
            <article class="article">
                <div class="row">
                    <div class="col-md-10 col-md-offset-1 panel panel-default">
                        <header class="header">
                            <div class="meta">
                        <span class="date">
                            <span class="month">10</span>
                            <span class="day">28</span>
                        </span>
                            </div>
                            <h3 class="title">
                                <a href="/2016/10/28/Linux-Terminal-Programming.html">Linux Terminal Programming</a>
                            </h3>
                        </header>
                        <section class="brief"><h1 id="abstract">ABSTRACT</h1>

<p>In the development of Enbeded Linux sytem, terminal is often used to get the input from keyboard.
The document is to introuduce how to operate keyboard and teminal in Linux system.</p>

<h1 id="1-keyboard-mode">1. Keyboard Mode</h1>

<p>There are four modes in Linux system.
To set Keyboard mode by ioctl function with the _kbd<em>mode</em> parameters.[1]</p>

<table>
<thead>
<tr>
<th>mode</th>
<th>define</th>
<th>value</th>
<th>remark</th>
</tr>
</thead>

<tbody>
<tr>
<td>scancode mode</td>
<td>K_RAW</td>
<td>0x00</td>
<td>raw mode, To read scancode from keyboard and save it to buffer.</td>
</tr>

<tr>
<td>Keycode mode</td>
<td>K_MEDIUMRAW</td>
<td>0x02</td>
<td>mediumraw mode ï¼šFliter the scancode and convert to Keycode.</td>
</tr>

<tr>
<td>ASCII mode</td>
<td>K_XLATE</td>
<td>0x01</td>
<td>XLATE mode: Convert to TTY Code.</td>
</tr>

<tr>
<td>UTF-8 MODE</td>
<td>K_UNICODE</td>
<td>0x03</td>
<td>Unicode modeï¼šSame as XLATEï¼Œexternal input UNICODE throw number keypad.</td>
</tr>
</tbody>
</table>

<h2 id="example">Example</h2>

<p>Here is an example of how to get and set keyboard mode.
At final, how to restore the keyboard mode.</p>
<pre><code>#include &lt;linux/kd.h&gt;
#include &lt;linux/key.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main() {
  long saved_mode;

  ioctl(STDIN_FILENO, KDGKBMODE, &amp;saved_mode);
  if (ioctl(STDIN_FILENO, KDSKBMODE, K_MEDIUMRAW) &lt; 0) {
    perror(&quot;set keyboard to mediuraw mode fail:&quot;);
    exit (EXIT_FAILURE);
  }

  /* 
   * do something... 
   */

  return ioctl(STDIN_FILENO, KDSKBMODE, saved_mode);
}
</code></pre>

<h1 id="2-terminal-interface">2. Terminal Interface</h1>

<p>POSIX systems support two basic modes of input: canonical and noncanonical. [2]</p>

<p>In canonical input processing mode,
terminal input is processed in lines terminated by newline (â€™\nâ€™), EOF, or EOL characters.
No input can be read until an entire line has been typed by the user,
and the read function returns at most a single line of input,
no matter how many bytes are requested.</p>

<p>In canonical input mode, the operating system provides input editing facilities:
some characters are interpreted specially to perform editing operations
within the current line of text, such as ERASE and KILL.</p>

<p>In noncanonical input processing mode, characters are not grouped into lines, and
ERASE and KILL processing is not performed. The granularity with which bytes are read in
noncanonical input mode is controlled by the MIN and TIME settings.</p>

<p>Most programs use canonical input mode, because this gives the user a way to edit
input line by line. The usual reason to use noncanonical mode is when the program accepts
single-character commands or provides its own editing facilities.</p>

<h2 id="terminal-modes">Terminal modes</h2>

<p>This section describes the various terminal attributes that control how input and output
are done. The functions, data structures, and symbolic constants are all declared in the
header file â€˜termios.hâ€™.</p>

<p>The entire collection of attributes of a terminal is stored in a structure of type <em>struct
termios</em>. This structure is used with the functions <em>tcgetattr</em> and <em>tcsetattr</em> to read and
set the attributes.</p>

<table>
<thead>
<tr>
<th>data type</th>
<th>name</th>
<th>remark</th>
</tr>
</thead>

<tbody>
<tr>
<td>tcflag_t</td>
<td>c_iflag</td>
<td>A bit mask specifying flags for input modes;</td>
</tr>

<tr>
<td>tcflag_t</td>
<td>c_oflag</td>
<td>A bit mask specifying flags for output modes;</td>
</tr>

<tr>
<td>tcflag_t</td>
<td>c_cflag</td>
<td>A bit mask specifying flags for control modes;</td>
</tr>

<tr>
<td>tcflag_t</td>
<td>c_lflag</td>
<td>A bit mask specifying flags for local modes;</td>
</tr>

<tr>
<td>cc_t</td>
<td>c_cc[NCCS]</td>
<td>An array specifying which characters are associated with various control functions;</td>
</tr>
</tbody>
</table>

<p><strong>tcflag_t</strong> This is an unsigned integer type used to represent the various bit masks for terminal
flags.</p>

<p><strong>cc_t</strong> This is an unsigned integer type used to represent characters associated with various
terminal control functions.</p>

<h2 id="terminal-model-functions">Terminal Model functions</h2>
<pre><code>int tcgetattr (int filedes, struct termios *termios-p)
</code></pre>

<p>This function is used to examine the attributes of the terminal device with file descriptor
filedes. The attributes are returned in the structure that <em>termios-p</em> points to.</p>

<p>If successful, <strong>tcgetattr</strong> returns 0. A return value of <strong>-1</strong> indicates an error.
The following <em>errno</em> error conditions are defined for this function:</p>

<p><strong>EBADF</strong> The filedes argument is not a valid file descriptor.</p>

<p><strong>ENOTTY</strong> The filedes is not associated with a terminal.</p>
<pre><code>int tcsetattr (int filedes, int when, const struct termios *termios-p)
</code></pre>

<p>This function sets the attributes of the terminal device with file descriptor filedes.
The new attributes are taken from the structure that <em>termios-p</em> points to.
The when argument specifies how to deal with input and output already queued. It
can be one of the following values:</p>

<table>
<thead>
<tr>
<th>when</th>
<th>Remark</th>
</tr>
</thead>

<tbody>
<tr>
<td>TCSANOW</td>
<td>Make the change immediately.</td>
</tr>

<tr>
<td>TCSADRAIN</td>
<td>Make the change after waiting until all queued output has been written. You should usually use this option when changing parameters that affect output.</td>
</tr>

<tr>
<td>TCSAFLUSH</td>
<td>This is like TCSADRAIN, but also discards any queued input.</td>
</tr>

<tr>
<td>TCSASOFT</td>
<td>This is a flag bit that you can add to any of the above alternatives. Its meaning is to inhibit alteration of the state of the terminal hardware. It is a BSD extension; it is only supported on BSD systems and the GNU system. <br>Using TCSASOFT is exactly the same as setting the CIGNORE it in the c_cflag member of the structure <em>termios-p</em> points to.</td>
</tr>
</tbody>
</table>

<p>If this function is called from a background process on its controlling terminal,
normally all processes in the process group are sent a SIGTTOU signal, in the same way
as if the process were trying to write to the terminal. The exception is if the calling
process itself is ignoring or blocking SIGTTOU signals, in which case the operation is
performed and no signal is sent.</p>

<p>If successful, tcsetattr returns 0. A return value of -1 indicates an error. The
following errno error conditions are defined for this function:</p>

<p><strong>EBADF</strong> The filedes argument is not a valid file descriptor.</p>

<p><strong>ENOTTY</strong> The filedes is not associated with a terminal.</p>

<p><strong>EINVAL</strong> Either the value of the when argument is not valid, or there is something
wrong with the data in the termios-p argument.</p>

<p>Although <strong>tcgetattr</strong> and <strong>tcsetattr</strong> specify the terminal device with a file descriptor,
the attributes are those of the terminal device itself and not of the file descriptor. This
means that the effects of changing terminal attributes are persistent; if another process
opens the terminal file later on, it will see the changed attributes even though it doesnâ€™t
have anything to do with the open file descriptor you originally specified in changing the
attributes.</p>

<p>Similarly, if a single process has multiple or duplicated file descriptors for the same
terminal device, changing the terminal attributes affects input and output to all of these
file descriptors. This means, for example, that you canâ€™t open one file descriptor or stream
to read from a terminal in the normal line-buffered, echoed mode; and simultaneously
have another file descriptor for the same terminal that you use to read from it in singlecharacter,
non-echoed mode. Instead, you have to explicitly switch the terminal back and
forth between the two modes.</p>

<h2 id="set-up-terminal-mode">Set up Terminal Mode</h2>

<p>When you set terminal modes, you should call <strong>tcgetattr</strong> first to get the current modes of
the particular terminal device, modify only those modes that you are really interested in,
and store the result with <strong>tcsetattr</strong>.</p>

<p>Itâ€™s a bad idea to simply initialize a struct <em>termios</em> structure to a chosen set of attributes
and pass it directly to tcsetattr. Your program may be run years from now, on
systems that support members not documented in this manual. The way to avoid setting
these members to unreasonable values is to avoid changing them.</p>

<p>Whatâ€™s more, different terminal devices may require different mode settings in order to
function properly. So you should avoid blindly copying attributes from one terminal device
to another.</p>

<p>When a member contains a collection of independent flags, as the c_iflag, c_oflag
and c_cflag members do, even setting the entire member is a bad idea, because particular
operating systems have their own flags. Instead, you should start with the current value
of the member and alter only the flags whose values matter in your program, leaving any
other flags unchanged.</p>

<h3 id="input-mode">Input Mode</h3>

<p>This section describes the terminal attribute flags that control fairly low-level aspects of
input processing: handling of parity errors, break signals, flow control, and RET and LFD
characters.</p>

<p>All of these flags are bits in the <strong>c_iflag</strong> member of the <em>struct termios</em> structure. The
member is an integer, and you change flags using the operators &amp;, | and ^. Donâ€™t try to
specify the entire value for <strong>c_iflag</strong>â€”instead, change only specific flags and leave the rest
untouched.</p>

<table>
<thead>
<tr>
<th>flag name</th>
<th>remark</th>
</tr>
</thead>

<tbody>
<tr>
<td>INPCK</td>
<td>If this bit is set, input parity checking is enabled. If it is not set, no checking at all is done for parity errors on input; the characters are simply passed through to the application. <br>Parity checking on input processing is independent of whether parity detection and generation on the underlying terminal hardware is enabled; <br>For example, you could clear the <strong>INPCK</strong> input mode flag and set the PARENB control mode flag to ignore parity errors on input, but still generate parity on output. <br>If this bit is set, what happens when a parity error is detected depends on whether the <strong>IGNPAR</strong> or <strong>PARMRK</strong> bits are set. If neither of these bits are set, a byte with a parity error is passed to the application as a â€™\0â€™ character.</td>
</tr>

<tr>
<td>IGNPAR</td>
<td>If this bit is set, any byte with a framing or parity error is ignored. This is only useful if <strong>INPCK</strong> is also set.</td>
</tr>

<tr>
<td>PARMRK</td>
<td>If this bit is set, input bytes with parity or framing errors are marked when passed to the program. This bit is meaningful only when <strong>INPCK</strong> is set and <strong>IGNPAR</strong> is not set. The way erroneous bytes are marked is with two preceding bytes, 377 and 0. Thus, the program actually reads three bytes for one erroneous byte received from the terminal.<br>If a valid byte has the value 0377, and <strong>ISTRIP</strong> (see below) is not set, the program might confuse it with the prefix that marks a parity error. So a valid byte 0377 is passed to the program as two bytes, 0377 0377, in this case.</td>
</tr>

<tr>
<td>ISTRIP</td>
<td>If this bit is set, valid input bytes are stripped to seven bits; otherwise, all eight bits are available for programs to read.</td>
</tr>

<tr>
<td>IGNBRK</td>
<td>If this bit is set, break conditions are ignored. A break condition is defined in the context of asynchronous serial data transmission as a series of zero-value bits longer than a single byte.</td>
</tr>

<tr>
<td>BRKINT</td>
<td>If this bit is set and IGNBRK is not set, a break condition clears the terminal input and output queues and raises a SIGINT signal for the foreground process group associatedwith the terminal.<br>If neither BRKINT nor IGNBRK are set, a break condition is passed to the application as a single â€™\0â€™ character if PARMRK is not set, or otherwise as a three-character sequence â€™\377â€™, â€™\0â€™, â€™\0â€™.</td>
</tr>

<tr>
<td>IGNCR</td>
<td>If this bit is set, carriage return characters (â€™\râ€™) are discarded on input. Discarding carriage return may be useful on terminals that send both carriage return and linefeed when you type the RET key.</td>
</tr>

<tr>
<td>ICRNL</td>
<td>If this bit is set and IGNCR is not set, carriage return characters (â€™\râ€™) received as input are passed to the application as newline characters (â€™\nâ€™).</td>
</tr>

<tr>
<td>INLCR</td>
<td>If this bit is set, newline characters (â€™\nâ€™) received as input are passed to the application as carriage return characters (â€™\râ€™).</td>
</tr>

<tr>
<td>IXOFF</td>
<td>If this bit is set, start/stop control on input is enabled. In other words, the computer sends STOP and START characters as necessary to prevent input from coming in faster than programs are reading it. The idea is that the actual terminal hardware that is generating the input data responds to a STOP character by suspending transmission, and to a START character by resuming transmission.</td>
</tr>

<tr>
<td>IXON</td>
<td>If this bit is set, start/stop control on output is enabled. In other words, if the computer receives a STOP character, it suspends output until a START character is received. In this case, the STOP and START characters are never passed to the application program. If this bit is not set, then START and STOP can be read as ordinary characters.</td>
</tr>

<tr>
<td>IXANY</td>
<td>If this bit is set, any input character restarts output when output has been suspended with the STOP character. Otherwise, only the START character restarts output. This is a BSD extension; it exists only on BSD systems and the GNU system.</td>
</tr>

<tr>
<td>IMAXBEL</td>
<td>If this bit is set, then filling up the terminal input buffer sends a BEL character (code 007) to the terminal to ring the bell.This is a BSD extension.</td>
</tr>
</tbody>
</table>

<h3 id="output-mode">Output Mode</h3>

<p>This section describes the terminal flags and fields that control how output characters are
translated and padded for display. All of these are contained in the c_oflag member of the
struct termios structure.</p>

<p>The <em>c_oflag</em> member itself is an integer, and you change the flags and fields using the
operators &amp;, |, and ^. Donâ€™t try to specify the entire value for c_oflagâ€”instead, change
only specific flags and leave the rest untouched.</p>

<table>
<thead>
<tr>
<th>flag name</th>
<th>remark</th>
</tr>
</thead>

<tbody>
<tr>
<td>OPOST</td>
<td>If this bit is set, output data is processed in some unspecified way so that it is displayed appropriately on the terminal device. This typically includes mapping newline characters (â€™\nâ€™) onto carriage return and linefeed pairs.<br>If this bit isnâ€™t set, the characters are transmitted as-is. The following three bits are BSD features, and they exist only BSD systems and the GNU system. They are effective only if OPOST is set.</td>
</tr>

<tr>
<td>ONLCR</td>
<td>If this bit is set, convert the newline character on output into a pair of characters, carriage return followed by linefeed.</td>
</tr>

<tr>
<td>OXTABS</td>
<td>If this bit is set, convert tab characters on output into the appropriate number of spaces to emulate a tab stop every eight columns.</td>
</tr>

<tr>
<td>ONOEOT</td>
<td>If this bit is set, discard C-d characters (code 004) on output. These characters cause many dial-up terminals to disconnect.</td>
</tr>
</tbody>
</table>

<h3 id="control-modes">Control Modes</h3>

<p>This section describes the terminal flags and fields that control parameters usually associated
with asynchronous serial data transmission. These flags may not make sense for other
kinds of terminal ports (such as a network connection pseudo-terminal). All of these are
contained in the c_cflag member of the struct termios structure.</p>

<p>The c_cflag member itself is an integer, and you change the flags and fields using the
operators &amp;, |, and ^. Donâ€™t try to specify the entire value for c_cflagâ€”instead, change
only specific flags and leave the rest untouched.</p>

<table>
<thead>
<tr>
<th>flag name</th>
<th>remark</th>
</tr>
</thead>

<tbody>
<tr>
<td>CLOCAL</td>
<td>If this bit is set, it indicates that the terminal is connected â€œlocallyâ€ and that the modem status lines (such as carrier detect) should be ignored.<br> On many systems if this bit is not set and you call open without the O_NONBLOCK flag set, open blocks until a modem connection is established.<br>If this bit is not set and a modem disconnect is detected, a SIGHUP signal is sent to the controlling process group for the terminal (if it has one). Normally, this causes the process to exit; see Chapter 24 [Signal Handling], page 590. Reading from the terminal after a disconnect causes an end-of-file condition, and writing causes an EIO error to be returned. The terminal device must be closed and reopened to clear the condition.</td>
</tr>

<tr>
<td>HUPCL</td>
<td>If this bit is set, a modem disconnect is generated when all processes that have the terminal device open have either closed the file or exited.</td>
</tr>

<tr>
<td>CREAD</td>
<td>If this bit is set, input can be read from the terminal. Otherwise, input is discarded when it arrives.</td>
</tr>

<tr>
<td>CSTOPB</td>
<td>If this bit is set, two stop bits are used. Otherwise, only one stop bit is used.</td>
</tr>

<tr>
<td>PARENB</td>
<td>If this bit is set, generation and detection of a parity bit are enabled. See <strong>Input Modes</strong> for information on how input parity errors are handled. If this bit is not set, no parity bit is added to output characters, and input characters are not checked for correct parity.</td>
</tr>

<tr>
<td>PARODD</td>
<td>This bit is only useful if PARENB is set. If PARODD is set, odd parity is used, otherwiseeven parity is used.<br>The control mode flags also includes a field for the number of bits per character. You can use the CSIZE macro as a mask to extract the value, like this: settings.c_cflag &amp; CSIZE.</td>
</tr>

<tr>
<td>CSIZE</td>
<td>This is a mask for the number of bits per character.</td>
</tr>

<tr>
<td>CS5</td>
<td>This specifies five bits per byte.</td>
</tr>

<tr>
<td>CS6</td>
<td>This specifies six bits per byte.</td>
</tr>

<tr>
<td>CS7</td>
<td>This specifies seven bits per byte.</td>
</tr>

<tr>
<td>CS8</td>
<td>This specifies eight bits per byte.</td>
</tr>
</tbody>
</table>

<h3 id="local-modes">Local Modes</h3>

<p>This section describes the flags for the c_lflag member of the struct termios structure.
These flags generally control higher-level aspects of input processing than the input modes
flags described in Section <strong>Input Modes</strong>, such as echoing, signals, and the
choice of canonical or noncanonical input.</p>

<p>The c_lflag member itself is an integer, and you change the flags and fields using the
operators &amp;, |, and ^. Donâ€™t try to specify the entire value for c_lflagâ€”instead, change
only specific flags and leave the rest untouched.</p>

<table>
<thead>
<tr>
<th>flag name</th>
<th>remark</th>
</tr>
</thead>

<tbody>
<tr>
<td>ICANON</td>
<td>This bit, if set, enables canonical input processing mode. Otherwise, input is processed in noncanonical mode.</td>
</tr>

<tr>
<td>ECHO</td>
<td>If this bit is set, echoing of input characters back to the terminal is enabled.</td>
</tr>

<tr>
<td>ECHOE</td>
<td>If this bit is set, echoing indicates erasure of input with the ERASE character by erasing the last character in the current line from the screen. Otherwise, the character erased is re-echoed to show what has happened (suitable for a printing terminal).<br> This bit only controls the display behavior; the ICANON bit by itself controls actual recognition of the ERASE character and erasure of input, without which ECHOE is simply irrelevant.</td>
</tr>

<tr>
<td>ECHOPRT</td>
<td>This bit is like ECHOE, enables display of the ERASE character in a way that is geared to a hardcopy terminal. When you type the ERASE character, a â€˜\â€™ character is printed followed by the first character erased. Typing the ERASE character again just prints the next character erased. Then, the next time you type a normal character, a â€˜/â€™ character is printed before the character echoes.<br>This is a BSD extension, and exists only in BSD systems and the GNU system.</td>
</tr>

<tr>
<td>ECHOK</td>
<td>This bit enables special display of the KILL character by moving to a new line after echoing the KILL character normally. The behavior of ECHOKE (below) is nicer to look at.<br> If this bit is not set, the KILL character echoes just as it would if it were not the KILL character. Then it is up to the user to remember that the KILL character has erased the preceding input; there is no indication of this on the screen. This bit only controls the display behavior; the ICANON bit by itself controls actual recognition of the KILL character and erasure of input, without which ECHOK is simply irrelevant.</td>
</tr>

<tr>
<td>ECHOKE</td>
<td>This bit is similar to ECHOK. It enables special display of the KILL character by erasing on the screen the entire line that has been killed. This is a BSD extension, and exists only in BSD systems and the GNU system.</td>
</tr>

<tr>
<td>ECHONL</td>
<td>If this bit is set and the ICANON bit is also set, then the newline (â€™\nâ€™) character isechoed even if the ECHO bit is not set.</td>
</tr>

<tr>
<td>ECHOCTL</td>
<td>If this bit is set and the ECHO bit is also set, echo control characters with â€˜^â€™ followed by the corresponding text character. Thus, control-A echoes as â€˜^Aâ€™. This is usually the preferred mode for interactive input, because echoing a control character back to the terminal could have some undesired effect on the terminal.<br>This is a BSD extension, and exists only in BSD systems and the GNU system.</td>
</tr>

<tr>
<td>ISIG</td>
<td>This bit controls whether the INTR, QUIT, and SUSP characters are recognized. The functions associated with these characters are performed if and only if this bit is set. Being in canonical or noncanonical input mode has no affect on the interpretation of these characters.<br> You should use caution when disabling recognition of these characters. Programs that cannot be interrupted interactively are very user-unfriendly. If you clear this bit, your program should provide some alternate interface that allows the user to interactively send the signals associated with these characters, or to escape from the program.</td>
</tr>

<tr>
<td>IEXTEN</td>
<td>POSIX.1 gives IEXTEN implementation-defined meaning, so you cannot rely on this interpretation on all systems.<br>On BSD systems and the GNU system, it enables the LNEXT and DISCARD characters.</td>
</tr>

<tr>
<td>NOFLSH</td>
<td>Normally, the INTR, QUIT, and SUSP characters cause input and output queues for the terminal to be cleared. If this bit is set, the queues are not cleared.</td>
</tr>

<tr>
<td>TOSTOP</td>
<td>If this bit is set and the system supports job control, then SIGTTOU signals are generatedby background processes that attempt to write to the terminal.<br>The following bits are BSD extensions; they exist only in BSD systems and the GNU system.</td>
</tr>

<tr>
<td>ALTWERASE</td>
<td>This bit determines how far the WERASE character should erase. The WERASE character erases back to the beginning of a word; the question is, where do words begin?<br>If this bit is clear, then the beginning of a word is a nonwhitespace character following a whitespace character. If the bit is set, then the beginning of a word is an alphanumeric character or underscore following a character which is none of those.</td>
</tr>

<tr>
<td>FLUSHO</td>
<td>This is the bit that toggles when the user types the DISCARD character. While this bit is set, all output is discarded.</td>
</tr>

<tr>
<td>NOKERNINFO</td>
<td>Setting this bit disables handling of the STATUS character.</td>
</tr>

<tr>
<td>PENDIN</td>
<td>If this bit is set, it indicates that there is a line of input that needs to be reprinted. Typing the REPRINT character sets this bit; the bit remains set until reprinting is finished.</td>
</tr>
</tbody>
</table>

<h3 id="noncanonical-input">Noncanonical Input</h3>

<p>In noncanonical input mode, the special editing characters such as ERASE and KILL are
ignored. The system facilities for the user to edit input are disabled in noncanonical mode,
so that all input characters (unless they are special for signal or flow-control purposes) are
passed to the application program exactly as typed. It is up to the application program to
give the user ways to edit the input, if appropriate.</p>

<p>Noncanonical mode offers special parameters called MIN and TIME for controlling
whether and how long to wait for input to be available. You can even use them to avoid
ever waitingâ€”to return immediately with whatever input is available, or with no input.
The MIN and TIME are stored in elements of the <strong>c_cc</strong> array, which is a member of
the struct termios structure. Each element of this array has a particular role, and each
element has a symbolic constant that stands for the index of that element. VMIN and VMAX
are the names for the indices in the array of the <strong>MIN</strong> and <strong>TIME</strong> slots.</p>

<h4 id="int-vmin">int VMIN</h4>

<p>This is the subscript for the MIN slot in the c_cc array. Thus, termios.c_cc[VMIN]
is the value itself.</p>

<p>The MIN slot is only meaningful in noncanonical input mode; it specifies the minimum
number of bytes that must be available in the input queue in order for read to return.</p>

<h4 id="int-vtime">int VTIME</h4>

<p>This is the subscript for the TIME slot in the c<em>cc array. Thus, termios.c</em>
cc[VTIME] is the value itself.</p>

<p>The TIME slot is only meaningful in noncanonical input mode; it specifies how long
to wait for input before returning, in units of 0.1 seconds.
The MIN and TIME values interact to determine the criterion for when read should
return; their precise meanings depend on which of them are nonzero. There are four possible
cases:</p>

<h4 id="both-time-and-min-are-nonzero">Both TIME and MIN are nonzero.</h4>

<p>In this case, TIME specifies how long to wait after each input character to see if more
input arrives. After the first character received, read keeps waiting until either MIN
bytes have arrived in all, or TIME elapses with no further input.
read always blocks until the first character arrives, even if TIME elapses first. read
can return more than MIN characters if more than MIN happen to be in the queue.</p>

<h4 id="both-min-and-time-are-zero"> Both MIN and TIME are zero.</h4>

<p>In this case, read always returns immediately with as many characters as are available
in the queue, up to the number requested. If no input is immediately available, read
returns a value of zero.</p>

<h4 id="min-is-zero-but-time-has-a-nonzero-value">MIN is zero but TIME has a nonzero value.</h4>

<p>In this case, read waits for time TIME for input to become available; the availability
of a single byte is enough to satisfy the read request and cause read to return. When
it returns, it returns as many characters as are available, up to the number requested.
If no input is available before the timer expires, read returns a value of zero.</p>

<h4 id="time-is-zero-but-min-has-a-nonzero-value">TIME is zero but MIN has a nonzero value.</h4>

<p>In this case, read waits until at least MIN bytes are available in the queue. At that
time, read returns as many characters as are available, up to the number requested.
read can return more than MIN characters if more than MIN happen to be in the
queue.</p>

<p>What happens if MIN is 50 and you ask to read just 10 bytes? Normally, read waits until
there are 50 bytes in the buffer (or, more generally, the wait condition described above is
satisfied), and then reads 10 of them, leaving the other 40 buffered in the operating system
for a subsequent call to read.</p>

<p>Portability note: On some systems, the MIN and TIME slots are actually the same as
the EOF and EOL slots. This causes no serious problem because the MIN and TIME slots
are used only in noncanonical input and the EOF and EOL slots are used only in canonical
input, but it isnâ€™t very clean. The GNU library allocates separate slots for these uses.</p>

<h2 id="noncanonical-mode-example">Noncanonical Mode Example</h2>
<pre><code>#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;termios.h&gt;

/* Use this variable to remember original terminal attributes. */
struct termios saved_attributes;
void reset_input_mode(void) {
  tcsetattr(STDIN_FILENO, TCSANOW, &amp;saved_attributes);
}

void set_input_mode(void) {
  struct termios tattr;
  char *name;
  /* Make sure stdin is a terminal. */
  if (!isatty(STDIN_FILENO)) {
    fprintf (stderr, &quot;Not a terminal.\n&quot;);
    exit (EXIT_FAILURE);
  }
  /* Save the terminal attributes so we can restore them later. */
  tcgetattr(STDIN_FILENO, &amp;saved_attributes);
  atexit(reset_input_mode);
  /* Set the funny terminal modes. */
  tcgetattr(STDIN_FILENO, &amp;tattr);
  tattr.c_lflag &amp;= ~(ICANON|ECHO); /* Clear ICANON and ECHO. */
  tattr.c_cc[VMIN] = 1;
  tattr.c_cc[VTIME] = 0;
  tcsetattr(STDIN_FILENO, TCSAFLUSH, &amp;tattr);
}

int main(void) {
  char c;
  set_input_mode();
  while (1) {
    read(STDIN_FILENO, &amp;c, 1);
    if (c == â€™\004â€™) break;  /* C-d */ 
    else putchar (c);
  }
  return EXIT_SUCCESS;
}
</code></pre>

<h1 id="references">REFERENCES</h1>

<p>[1] Console_ioctl(4). <a href="http://man7.org/linux/man-pages/man4/console_ioctl.4.html">http://man7.org/linux/man-pages/man4/console_ioctl.4.html</a></p>

<p>[2] Richard M. Stallman, Roland McGrath. The GNU C Library Reference Manual version 2.8. 17:433-455, 2007-10-27.</p>
</section>
                        <aside class="aside clearfix">
                            <a class="btn btn-primary btn-lg pull-right" href="/2016/10/28/Linux-Terminal-Programming.html">Read More</a>
                        </aside>
                    </div>
                </div>
            </article>
            
            <article class="article">
                <div class="row">
                    <div class="col-md-10 col-md-offset-1 panel panel-default">
                        <header class="header">
                            <div class="meta">
                        <span class="date">
                            <span class="month">10</span>
                            <span class="day">26</span>
                        </span>
                            </div>
                            <h3 class="title">
                                <a href="/2016/10/26/Set-Up-Git-Server-With-SSH.html">Set Up Git Server With SSH</a>
                            </h3>
                        </header>
                        <section class="brief"><p>This Document is a copy of <a href="https://www.google.com/search?hl=zh-CN&amp;q=markdown">Git on the Server - Setting Up the Server</a></p>

<h1 id="setting-up-server">Setting Up Server</h1>

<p>Letâ€™s walk through setting up SSH access on the server side.
In this example, youâ€™ll use the authorized_keys method for authenticating your users.
We also assume youâ€™re running a standard Linux distribution like Ubuntu.
First, you create a git user and a .ssh directory for that user.</p>
<pre><code>$ sudo adduser git
$ su git
$ cd
$ mkdir .ssh &amp;&amp; chmod 700 .ssh
$ touch .ssh/authorized_keys &amp;&amp; chmod 600 .ssh/authorized_keys
</code></pre>

<p>Next, you need to add some developer SSH public keys to the authorized_keys file for the git user.
Letâ€™s assume you have some trusted public keys and have saved them to temporary files.
Again, the public keys look something like this:</p>
<pre><code>$ cat /tmp/id_rsa.pub
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCB007n/ww+ouN4gSLKssMxXnBOvf9LGt4L
ojG6rs6hPB09j9R/T17/x4lhJA0F3FR1rP6kYBRsWj2aThGw6HXLm9/5zytK6Ztg3RPKK+4k
Yjh6541NYsnEAZuXz0jTTyAUfrtU3Z5E003C4oxOj6H0rfIF1kKI9MAQLMdpGW1GYEIgS9Ez
Sdfd8AcCIicTDWbqLAcU4UpkaX8KyGlLwsNuuGztobF8m72ALC/nLF6JLtPofwFBlgc+myiv
O7TCUSBdLQlgMVOFq1I2uPWQOkOWQAHukEOmfjy2jctxSDBQ220ymjaNsHT4kgtZg2AYYgPq
dAv8JggJICUvax2T9va5 gsg-keypair
</code></pre>

<p>You just append them to the git userâ€™s authorized_keys file in its .ssh directory:</p>

<p>$ cat /tmp/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</p>

<p>Now, you can set up an empty repository for them by running git init with the --bare option,
which initializes the repository without a working directory:</p>
<pre><code>$ cd /opt/git
$ mkdir project.git
$ cd project.git
$ git init --bare
Initialized empty Git repository in /opt/git/project.git
</code></pre>

<p>At last, you can clone it down and push changes back up just as easily:</p>
<pre><code>$ git clone git@gitserver:/opt/git/project.git
$ cd project
$ vim README
$ git commit -am 'fix for the README file'
$ git push origin master
</code></pre>

<p>With this method, you can quickly get a read/write Git server up and running
for a handful of developers.</p>

<h1 id="forbidden-login">Forbidden login</h1>

<p>You should note that currently all these users can also log into the server and
get a shell as the git user.
If you want to restrict that,
you will have to change the shell to something else in the passwd file.</p>

<p>You can easily restrict the git user to only doing Git activities
with a limited shell tool called git-shell that comes with Git.
If you set this as your git userâ€™s login shell,
then the git user canâ€™t have normal shell access to your server.
To use this, specify git-shell instead of bash or csh for your userâ€™s login shell.
To do so, you must first add git-shell to /etc/shells if itâ€™s not already there:</p>
<pre><code>$ cat /etc/shells   # see if `git-shell` is already in there.  If not...
$ which git-shell   # make sure git-shell is installed on your system.
$ sudo vim /etc/shells  # and add the path to git-shell from last command
</code></pre>

<p>Now you can edit the shell for a user using chsh <username>:</p>
<pre><code>$ sudo chsh git  # and enter the path to git-shell, usually: /usr/bin/git-shell
</code></pre>

<p>Now, the git user can only use the SSH connection to push and
pull Git repositories and canâ€™t shell onto the machine.
If you try, youâ€™ll see a login rejection like this:</p>
<pre><code>$ ssh git@gitserver
fatal: Interactive git shell is not enabled.
hint: ~/git-shell-commands should exist and have read and execute access.
Connection to gitserver closed.
</code></pre>

<p>Now Git network commands will still work just fine but the users wonâ€™t be able to get a shell.
As the output states,
you can also set up a directory in the git userâ€™s home directory
that customizes the git-shell command a bit.
For instance,
you can restrict the Git commands that the server will accept
or you can customize the message that users see
if they try to SSH in like that.
Run git help shell for more information on customizing the shell.</p>
</section>
                        <aside class="aside clearfix">
                            <a class="btn btn-primary btn-lg pull-right" href="/2016/10/26/Set-Up-Git-Server-With-SSH.html">Read More</a>
                        </aside>
                    </div>
                </div>
            </article>
            
            <article class="article">
                <div class="row">
                    <div class="col-md-10 col-md-offset-1 panel panel-default">
                        <header class="header">
                            <div class="meta">
                        <span class="date">
                            <span class="month">10</span>
                            <span class="day">25</span>
                        </span>
                            </div>
                            <h3 class="title">
                                <a href="/2016/10/25/vim-notes.html">vim notes</a>
                            </h3>
                        </header>
                        <section class="brief"><p>è®°å½•ä¸€äº›ç½‘ä¸Šæ”¶é›†çš„VIMçš„ä½¿ç”¨æ‰‹å†ŒåŠçŸ¥è¯†ç‚¹</p>

<h1 id="å®å‘½ä»¤ç›¸å…³">å®å‘½ä»¤ç›¸å…³</h1>
<pre><code>:qx å¼€å§‹è®°å½•å®ï¼Œå¹¶å°†ç»“æœå­˜å…¥å¯„å­˜å™¨x
q é€€å‡ºè®°å½•æ¨¡å¼
@x æ’­æ”¾è®°å½•åœ¨xå¯„å­˜å™¨ä¸­çš„å®å‘½ä»¤
</code></pre>

<p>ç¨å¾®è§£é‡Šä¸€ä¸‹ï¼Œå½“åœ¨normalæ¨¡å¼ä¸‹è¾“å…¥:qxåï¼Œä½ å¯¹æ–‡æœ¬çš„æ‰€æœ‰ç¼–è¾‘åŠ¨ä½œå°†ä¼šè¢«è®°å½•ä¸‹æ¥ï¼Œå†æ¬¡è¾“å…¥qå³é€€å‡ºäº†è®°å½•æ¨¡
å¼ï¼Œç„¶åè¾“å…¥@xå¯¹åˆšæ‰è®°å½•ä¸‹æ¥çš„å‘½ä»¤è¿›è¡Œé‡å¤ï¼Œæ­¤å‘½ä»¤åå¯è·Ÿæ•°å­—ï¼Œè¡¨ç¤ºè¦é‡å¤å¤šå°‘æ¬¡ï¼Œæ¯”å¦‚@x20ï¼Œå¯ä»¥é‡å¤20æ¬¡ã€‚è¿™ä¸ªåœ¨æ–‡æœ¬çš„æ‰¹å¤„ç†ä¸­æ˜¯éå¸¸æœ‰ç”¨çš„ã€‚</p>

<h1 id="æ ‡ç­¾å‘½ä»¤">æ ‡ç­¾å‘½ä»¤</h1>

<p>åœ¨vimä¼—å¤šçš„æ’ä»¶ä¸­ï¼Œæœ‰ä¸€ä¸ªå«minibufferçš„æ’ä»¶ï¼Œå°±æ˜¯ä¸‹é¢æ‰€è¯´çš„æ ‡ç­¾é¡µåŠŸèƒ½äº†ï¼Œå¯ä»¥æ”¯æŒåŒæ—¶ç¼–è¾‘å¤šä¸ªæ–‡ä»¶ã€‚</p>
<pre><code>å½“ä½ æŠŠå…‰æ ‡ç½®äºè¿™ä¸ªçª—å£æ—¶, æœ‰ä¸‹é¢å‡ ä¸ªå¿«æ·é”®å¯ä»¥ç”¨:
å‘å‰å¾ªç¯åˆ‡æ¢åˆ°æ¯ä¸ªbufferåä¸Š
å‘åå¾ªç¯åˆ‡æ¢åˆ°æ¯ä¸ªbufferåä¸Š
åœ¨æ‰“å¼€å…‰æ ‡æ‰€åœ¨çš„buffer
d åˆ é™¤å…‰æ ‡æ‰€åœ¨çš„buffer
</code></pre>

<h1 id="å‘½ä»¤æ¨¡å¼">å‘½ä»¤æ¨¡å¼</h1>
<pre><code>:tabe fn åœ¨ä¸€ä¸ªæ–°çš„æ ‡ç­¾é¡µä¸­ç¼–è¾‘æ–‡ä»¶fn
gt åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªæ ‡ç­¾é¡µ
gT åˆ‡æ¢åˆ°ä¸Šä¸€ä¸ªæ ‡ç­¾é¡µ
:tabr åˆ‡æ¢åˆ°ç¬¬ä¸€ä¸ªæ ‡ç­¾é¡µ
:tabl åˆ‡æ¢åˆ°æœ€åä¸€ä¸ªæ ‡ç­¾é¡µ
:tabm [N] æŠŠå½“å‰tabç§»åŠ¨åˆ°ç¬¬Nä¸ªtabä¹‹å

:e file æŠŠfileåŠ è½½åˆ°æ–°çš„ç¼“å†²åŒºä¸­
:bn æ‰“å¼€å½“å‰bufferçš„ä¸‹ä¸€ä¸ªbuffer
:bp æ‰“å¼€å½“å‰bufferçš„å‰ä¸€ä¸ªbuffer
:bâ€numâ€ æ‰“å¼€æŒ‡å®šçš„bufferï¼Œâ€numâ€æŒ‡çš„æ˜¯bufferå¼€å§‹çš„é‚£ä¸ªæ•°å­—ï¼Œæ¯”å¦‚ä¸Šå›¾ï¼Œæˆ‘æƒ³æ‰“å¼€list_audit.erbï¼Œè¾“å…¥:b7å°±okäº†
:bd åˆ é™¤ç¼“å†²åŒº(å…³é—­æ–‡ä»¶)

:sp fn åˆ†å‰²çª—å£ï¼Œå¹¶å°†fnåŠ è½½åˆ°æ–°çš„çª—å£ä¸­
</code></pre>

<h1 id="é€€å‡ºç¼–è¾‘å™¨">é€€å‡ºç¼–è¾‘å™¨</h1>
<pre><code>:w å°†ç¼“å†²åŒºå†™å…¥æ–‡ä»¶ï¼Œå³ä¿å­˜ä¿®æ”¹
:wq ä¿å­˜ä¿®æ”¹å¹¶é€€å‡º
:x ä¿å­˜ä¿®æ”¹å¹¶é€€å‡º
:q é€€å‡ºï¼Œå¦‚æœå¯¹ç¼“å†²åŒºè¿›è¡Œè¿‡ä¿®æ”¹ï¼Œåˆ™ä¼šæç¤º
:q! å¼ºåˆ¶é€€å‡ºï¼Œæ”¾å¼ƒä¿®æ”¹
</code></pre>

<h1 id="æŸ¥æ‰¾æ›¿æ¢">æŸ¥æ‰¾æ›¿æ¢</h1>
<pre><code>/pattern å‘åæœç´¢å­—ç¬¦ä¸²pattern
?pattern å‘å‰æœç´¢å­—ç¬¦ä¸²pattern
n ä¸‹ä¸€ä¸ªåŒ¹é…(å¦‚æœæ˜¯/æœç´¢ï¼Œåˆ™æ˜¯å‘ä¸‹çš„ä¸‹ä¸€ä¸ªï¼Œ?æœç´¢åˆ™æ˜¯å‘ä¸Šçš„ä¸‹ä¸€ä¸ª)
N ä¸Šä¸€ä¸ªåŒ¹é…(åŒä¸Š)
:%s/old/new/g æœç´¢æ•´ä¸ªæ–‡ä»¶ï¼Œå°†æ‰€æœ‰çš„oldæ›¿æ¢ä¸ºnew
:%s/old/new/gc æœç´¢æ•´ä¸ªæ–‡ä»¶ï¼Œå°†æ‰€æœ‰çš„oldæ›¿æ¢ä¸ºnewï¼Œæ¯æ¬¡éƒ½è¦ä½ ç¡®è®¤æ˜¯å¦æ›¿æ¢
</code></pre>

<h1 id="å¤åˆ¶ç²˜è´´">å¤åˆ¶ç²˜è´´</h1>
<pre><code>dd åˆ é™¤å…‰æ ‡æ‰€åœ¨è¡Œ
dw åˆ é™¤ä¸€ä¸ªå­—(word)
x åˆ é™¤å½“å‰å­—ç¬¦
X åˆ é™¤å‰ä¸€ä¸ªå­—ç¬¦
D åˆ é™¤åˆ°è¡Œæœ«
yy å¤åˆ¶ä¸€è¡Œï¼Œæ­¤å‘½ä»¤å‰å¯è·Ÿæ•°å­—ï¼Œæ ‡è¯†å¤åˆ¶å¤šè¡Œï¼Œå¦‚6yyï¼Œè¡¨ç¤ºä»å½“å‰è¡Œå¼€å§‹å¤åˆ¶6è¡Œ
yw å¤åˆ¶ä¸€ä¸ªå­—
y$ å¤åˆ¶åˆ°è¡Œæœ«
p ç²˜è´´ç²˜è´´æ¿çš„å†…å®¹åˆ°å½“å‰è¡Œçš„ä¸‹é¢
P ç²˜è´´ç²˜è´´æ¿çš„å†…å®¹åˆ°å½“å‰è¡Œçš„ä¸Šé¢
]p æœ‰ç¼©è¿›çš„ç²˜è´´ï¼Œvimä¼šè‡ªåŠ¨è°ƒèŠ‚ä»£ç çš„ç¼©è¿›
â€œa å°†å†…å®¹æ”¾å…¥/å­˜å…¥aå¯„å­˜å™¨ï¼Œå¯ä»¥æ”¯æŒå¤šç²˜è´´æ¿
</code></pre>

<p>é™„ï¼šæ¯”å¦‚å¸¸ç”¨çš„ä¸€ä¸ªå¯„å­˜å™¨å°±æ˜¯ç³»ç»Ÿå¯„å­˜å™¨ï¼Œåç§°ä¸º+ï¼Œæ‰€ä»¥ä»ç³»ç»Ÿç²˜è´´æ¿ç²˜è´´åˆ°vimä¸­çš„å‘½ä»¤ä¸ºâ€+p,æ³¨æ„æ­¤å¤„çš„+ä¸è¡¨ç¤ºæ“ä½œç¬¦ï¼ŒäºŒåä¸€ä¸ªå¯„å­˜å™¨ã€‚</p>

<h1 id="ç§»åŠ¨å…‰æ ‡">ç§»åŠ¨å…‰æ ‡</h1>

<p>åœ¨vimä¸­ç§»åŠ¨å…‰æ ‡è·Ÿå…¶ä»–çš„ç¼–è¾‘å™¨ä¸­æœ‰å¾ˆå¤§çš„åŒºåˆ«ï¼Œä¸è¿‡ä¸€æ—¦å­¦ä¼šäº†ï¼Œå°±ä¼šé£é€Ÿçš„åœ¨æ–‡æœ¬ä¸­ç§»åŠ¨äº†ã€‚</p>
<pre><code>h,j,k,l ä¸Šï¼Œä¸‹ï¼Œå·¦ï¼Œå³
ctrl-f ä¸Šç¿»ä¸€é¡µ
ctrl-b ä¸‹ç¿»ä¸€é¡µ
% è·³åˆ°ä¸å½“å‰æ‹¬å·åŒ¹é…çš„æ‹¬å·å¤„ï¼Œå¦‚å½“å‰åœ¨{ï¼Œåˆ™è·³è½¬åˆ°ä¸ä¹‹åŒ¹é…çš„}å¤„
w è·³åˆ°ä¸‹ä¸€ä¸ªå­—é¦–ï¼ŒæŒ‰æ ‡ç‚¹æˆ–å•è¯åˆ†å‰²
W è·³åˆ°ä¸‹ä¸€ä¸ªå­—é¦–ï¼Œé•¿è·³ï¼Œå¦‚end-of-lineè¢«è®¤ä¸ºæ˜¯ä¸€ä¸ªå­—
e è·³åˆ°ä¸‹ä¸€ä¸ªå­—å°¾
E è·³åˆ°ä¸‹ä¸€ä¸ªå­—å°¾ï¼Œé•¿è·³
b è·³åˆ°ä¸Šä¸€ä¸ªå­—
B è·³åˆ°ä¸Šä¸€ä¸ªå­—ï¼Œé•¿è·³
0 è·³è‡³è¡Œé¦–ï¼Œä¸ç®¡æœ‰æ— ç¼©è¿›ï¼Œå°±æ˜¯è·³åˆ°ç¬¬0ä¸ªå­—ç¬¦
^ è·³è‡³è¡Œé¦–çš„ç¬¬ä¸€ä¸ªå­—ç¬¦
$ è·³è‡³è¡Œå°¾
gg è·³è‡³æ–‡ä»¶çš„ç¬¬ä¸€è¡Œ
gd è·³è‡³å½“å‰å…‰æ ‡æ‰€åœ¨çš„å˜é‡çš„å£°æ˜å¤„
[N]G è·³åˆ°ç¬¬Nè¡Œï¼Œå¦‚0Gï¼Œå°±ç­‰ä»·äºggï¼Œ100Gå°±æ˜¯ç¬¬100è¡Œ
fx åœ¨å½“å‰è¡Œä¸­æ‰¾xå­—ç¬¦ï¼Œæ‰¾åˆ°äº†å°±è·³è½¬è‡³
; é‡å¤ä¸Šä¸€ä¸ªfå‘½ä»¤ï¼Œè€Œä¸ç”¨é‡å¤çš„è¾“å…¥fx
tx ä¸fxç±»ä¼¼ï¼Œä½†æ˜¯åªæ˜¯è·³è½¬åˆ°xçš„å‰ä¸€ä¸ªå­—ç¬¦å¤„
Fx è·Ÿfxçš„æ–¹å‘ç›¸å
),( è·³è½¬åˆ°ä¸Š/ä¸‹ä¸€ä¸ªè¯­å¥
* æŸ¥æ‰¾å…‰æ ‡æ‰€åœ¨å¤„çš„å•è¯ï¼Œå‘ä¸‹æŸ¥æ‰¾
# æŸ¥æ‰¾å…‰æ ‡æ‰€åœ¨å¤„çš„å•è¯ï¼Œå‘ä¸ŠæŸ¥æ‰¾
`. è·³è½¬è‡³ä¸Šæ¬¡ç¼–è¾‘ä½ç½®
åœ¨å±å¹•ä¸Šç§»åŠ¨

H ç§»åŠ¨å…‰æ ‡åˆ°å½“å‰å±å¹•ä¸Šæœ€ä¸Šè¾¹çš„ä¸€è¡Œ
M ç§»åŠ¨å…‰æ ‡åˆ°å½“å‰å±å¹•ä¸Šä¸­é—´çš„ä¸€è¡Œ
L ç§»åŠ¨å…‰æ ‡åˆ°å½“å‰å±å¹•ä¸Šæœ€ä¸‹è¾¹çš„ä¸€è¡Œ
</code></pre>

<h1 id="ä¹¦ç­¾">ä¹¦ç­¾</h1>
<pre><code>ma æŠŠå½“å‰ä½ç½®å­˜æˆæ ‡ç­¾a
`a è·³è½¬åˆ°æ ‡ç­¾aå¤„
</code></pre>

<h1 id="ç¼–è¾‘">ç¼–è¾‘</h1>
<pre><code>r æ›¿æ¢ä¸€ä¸ªå­—ç¬¦
J å°†ä¸‹ä¸€è¡Œå’Œå½“å‰è¡Œè¿æ¥ä¸ºä¸€è¡Œ
cc åˆ é™¤å½“å‰è¡Œå¹¶è¿›å…¥ç¼–è¾‘æ¨¡å¼
cw åˆ é™¤å½“å‰å­—ï¼Œå¹¶è¿›å…¥ç¼–è¾‘æ¨¡å¼
c$ æ“¦é™¤ä»å½“å‰ä½ç½®è‡³è¡Œæœ«çš„å†…å®¹ï¼Œå¹¶è¿›å…¥ç¼–è¾‘æ¨¡å¼
s åˆ é™¤å½“å‰å­—ç¬¦å¹¶è¿›å…¥ç¼–è¾‘æ¨¡å¼
S åˆ é™¤å…‰æ ‡æ‰€åœ¨è¡Œå¹¶è¿›å…¥ç¼–è¾‘æ¨¡å¼
xp äº¤æ¢å½“å‰å­—ç¬¦å’Œä¸‹ä¸€ä¸ªå­—ç¬¦
u æ’¤é”€
ctrl+r é‡åš
. é‡å¤ä¸Šä¸€ä¸ªç¼–è¾‘å‘½ä»¤
~ åˆ‡æ¢å¤§å°å†™ï¼Œå½“å‰å­—ç¬¦
g~iw åˆ‡æ¢å½“å‰å­—çš„å¤§å°å†™
gUiw å°†å½“å‰å­—å˜æˆå¤§å†™
guiw å°†å½“å‰å­—å˜æˆå°å†™
&gt;&gt; å°†å½“å‰è¡Œå³ç§»ä¸€ä¸ªå•ä½
&lt;&lt; å°†å½“å‰è¡Œå·¦ç§»ä¸€ä¸ªå•ä½(ä¸€ä¸ªtabç¬¦)
== è‡ªåŠ¨ç¼©è¿›å½“å‰è¡Œ
</code></pre>

<h1 id="æ’å…¥æ¨¡å¼">æ’å…¥æ¨¡å¼</h1>
<pre><code>i ä»å½“å‰å…‰æ ‡å¤„è¿›å…¥æ’å…¥æ¨¡å¼
I è¿›å…¥æ’å…¥æ¨¡å¼ï¼Œå¹¶ç½®å…‰æ ‡äºè¡Œé¦–
a è¿½åŠ æ¨¡å¼ï¼Œç½®å…‰æ ‡äºå½“å‰å…‰æ ‡ä¹‹å
A è¿½åŠ æ¨¡å¼ï¼Œç½®å…‰æ ‡äºè¡Œæœ«
o åœ¨å½“å‰è¡Œä¹‹ä¸‹æ–°åŠ ä¸€è¡Œï¼Œå¹¶è¿›å…¥æ’å…¥æ¨¡å¼
O åœ¨å½“å‰è¡Œä¹‹ä¸Šæ–°åŠ ä¸€è¡Œï¼Œå¹¶è¿›å…¥æ’å…¥æ¨¡å¼
Esc é€€å‡ºæ’å…¥æ¨¡å¼
</code></pre>

<h1 id="å¯è§†æ¨¡å¼">å¯è§†æ¨¡å¼</h1>

<h2 id="æ ‡è®°æ–‡æœ¬">æ ‡è®°æ–‡æœ¬</h2>
<pre><code>v è¿›å…¥å¯è§†æ¨¡å¼ï¼Œå•å­—ç¬¦æ¨¡å¼
V è¿›å…¥å¯è§†æ¨¡å¼ï¼Œè¡Œæ¨¡å¼
ctrl+v è¿›å…¥å¯è§†æ¨¡å¼ï¼Œåˆ—æ¨¡å¼ï¼Œç±»ä¼¼äºUEçš„åˆ—æ¨¡å¼
o è·³è½¬å…‰æ ‡åˆ°é€‰ä¸­å—çš„å¦ä¸€ä¸ªç«¯ç‚¹
U å°†é€‰ä¸­å—ä¸­çš„å†…å®¹è½¬æˆå¤§å†™
O è·³è½¬å…‰æ ‡åˆ°å—çš„å¦ä¸€ä¸ªç«¯ç‚¹
aw é€‰ä¸­ä¸€ä¸ªå­—
ab é€‰ä¸­æ‹¬å·ä¸­çš„æ‰€æœ‰å†…å®¹ï¼ŒåŒ…æ‹¬æ‹¬å·æœ¬èº«
aB é€‰ä¸­{}æ‹¬å·ä¸­çš„æ‰€æœ‰å†…å®¹
ib é€‰ä¸­æ‹¬å·ä¸­çš„å†…å®¹ï¼Œä¸å«æ‹¬å·
iB é€‰ä¸­{}ä¸­çš„å†…å®¹ï¼Œä¸å«{}
</code></pre>

<h2 id="å¯¹æ ‡è®°è¿›è¡ŒåŠ¨ä½œ">å¯¹æ ‡è®°è¿›è¡ŒåŠ¨ä½œ</h2>
<pre><code>&gt; å—å³ç§»
&lt; å—å·¦ç§»
y å¤åˆ¶å—
d åˆ é™¤å—
~ åˆ‡æ¢å—ä¸­å†…å®¹çš„å¤§å°å†™
</code></pre>

<h1 id="çª—å£å‘½ä»¤">çª—å£å‘½ä»¤</h1>
<pre><code>ctrl+w s æ°´å¹³åˆ†å‰²çª—å£
ctrl+w w åˆ‡æ¢çª—å£
ctrl+w q é€€å‡ºå½“å‰çª—å£(ç”±äºåŒæ—¶æœ‰å¤šä¸ªæ–‡ä»¶ï¼Œæ­¤å‘½ä»¤ä¸ä¼šå½±å“å…¶ä»–çª—å£)
ctrl+w v å‚ç›´åˆ†å‰²çª—å£
CTRL-W = ä½¿å¾—æ‰€æœ‰çª—å£ (å‡ ä¹) ç­‰å®½ã€ç­‰é«˜ï¼Œä½†å½“å‰çª—å£ä½¿ç”¨ â€˜winheightâ€™ å’Œ â€˜winwidthâ€™ã€‚

:res[ize] -N
CTRL-W â€“ ä½¿å¾—å½“å‰çª—å£é«˜åº¦å‡ N (é»˜è®¤å€¼æ˜¯ 1)ã€‚å¦‚æœåœ¨ â€˜verticalâ€™ ä¹‹åä½¿ç”¨ï¼Œåˆ™ä½¿å¾—å®½åº¦å‡ Nã€‚

:res[ize] +N
CTRL-W + ä½¿å¾—å½“å‰çª—å£é«˜åº¦åŠ  N (é»˜è®¤å€¼æ˜¯ 1)ã€‚å¦‚æœåœ¨ â€˜verticalâ€™ ä¹‹åä½¿ç”¨ï¼Œåˆ™ä½¿å¾—å®½åº¦åŠ  Nã€‚

:res[ize] [N]
CTRL-W CTRL-_
CTRL-W _ è®¾ç½®å½“å‰çª—å£çš„é«˜åº¦ä¸º N (é»˜è®¤å€¼ä¸ºæœ€å¤§å¯èƒ½é«˜åº¦)ã€‚

:vertical res[ize] [N]
CTRL-W | è®¾ç½®å½“å‰çª—å£çš„å®½åº¦ä¸º N (é»˜è®¤å€¼ä¸ºæœ€å¤§å¯èƒ½å®½åº¦)ã€‚

z{nr}&lt;CR&gt; è®¾ç½®å½“å‰çª—å£çš„é«˜åº¦ä¸º {nr}ã€‚

CTRL-W &lt; ä½¿å¾—å½“å‰çª—å£å®½åº¦å‡ N (é»˜è®¤å€¼æ˜¯ 1)ã€‚
CTRL-W &gt; ä½¿å¾—å½“å‰çª—å£å®½åº¦åŠ  N (é»˜è®¤å€¼æ˜¯ 1)ã€‚

&lt;æ•´ä¸ªçª—å£çš„ç§»åŠ¨&gt;
CTRL-W-H å°†çª—å£ç§»åˆ°æœ€å·¦è¾¹
CTRL-W-L å°†çª—å£ç§»åˆ°æœ€å³è¾¹
CTRL-W-J å°†çª—å£ç§»åˆ°åº•ç«¯
CTRL-W-K å°†çª—å£ç§»åˆ°é¡¶ç«¯
</code></pre>
</section>
                        <aside class="aside clearfix">
                            <a class="btn btn-primary btn-lg pull-right" href="/2016/10/25/vim-notes.html">Read More</a>
                        </aside>
                    </div>
                </div>
            </article>
            
            <div class="article-pager text-center">
                
                
            </div>
        </div>
    </div>
</section>
<footer id="footer">
    <div class="container text-center">
        <p>Â© 2015 Zero Sky.
            <a href="http://creativecommons.org/licenses/by/3.0/">All rights reserved </a> |
            <a href="/feed.xml">Feed</a> |
            <a href="/sitemap.xml">Sitemap</a>
        </p>
        <p>Powered by <a href="https://github.com/go-xiaohei/pugo">PuGo 0.10.5 (beta)</a>. Theme by Default.
        </p>
        
    
    

    </div>
</footer>
<script src="/js/jquery-2.1.4.min.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/prism.min.js"></script>
<script>
    $(document).ready(function () {
        $("pre code").addClass("line-numbers")
    });
</script>
</body>
</html>
