<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>Page 1 - Zero Sky</title>
    <meta name="keywords" content="C&#43;&#43; Golang React Python Vim"/>
    <meta name="description" content="PuGo is a Simple Static Site Generator"/>
    <link rel="stylesheet" href="/css/bootstrap.min.css"/>
    <link rel="stylesheet" href="/css/prism.css"/>
    <link rel="stylesheet" href="/css/style.css"/>
</head>
<body class="post-list" data-perma="post-page-1">
<header id="header">
    <div class="container">
        <div class="header clearfix">
            <nav id="site-nav">
                <ul class="nav nav-inverse nav-pills pull-right">
                    <li role="presentation" class="">
                        <a href="/" >Home
                        </a>
                    </li>
                    <li role="presentation" class="">
                        <a href="/archive.html" >Archive
                        </a>
                    </li>
                    <li role="presentation" class="">
                        <a href="/about.html" >About
                        </a>
                    </li>
                    <li role="presentation" class="">
                        <a href="https://github.com/netdigger/blog"  target="_blank" >Source
                        </a>
                    </li>
                </ul>
            </nav>
            <h3 id="site-title">
                <a href="/">Zero Sky <sup>Notes of Programmer</sup></a>
            </h3>
        </div>
    </div>
</header>

<section id="main">
    <div class="container">
        <div id="article-list">
            <article class="article">
                <div class="row">
                    <div class="col-md-10 col-md-offset-1 panel panel-default">
                        <header class="header">
                            <div class="meta">
                        <span class="date">
                            <span class="month">10</span>
                            <span class="day">28</span>
                        </span>
                            </div>
                            <h3 class="title">
                                <a href="/2016/10/28/Linux-Terminal-Programming.html">Linux Terminal Programming</a>
                            </h3>
                        </header>
                        <section class="brief"><h1 id="abstract">ABSTRACT</h1>

<p>In the development of Enbeded Linux sytem, terminal is often used to get the input from keyboard.
The document is to introuduce how to operate keyboard and teminal in Linux system.</p>

<h1 id="1-keyboard-mode">1. Keyboard Mode</h1>

<p>There are four modes in Linux system.
To set Keyboard mode by ioctl function with the _kbd<em>mode</em> parameters.[1]</p>

<table>
<thead>
<tr>
<th>mode</th>
<th>define</th>
<th>value</th>
<th>remark</th>
</tr>
</thead>

<tbody>
<tr>
<td>scancode mode</td>
<td>K_RAW</td>
<td>0x00</td>
<td>raw mode, To read scancode from keyboard and save it to buffer.</td>
</tr>

<tr>
<td>Keycode mode</td>
<td>K_MEDIUMRAW</td>
<td>0x02</td>
<td>mediumraw mode ：Fliter the scancode and convert to Keycode.</td>
</tr>

<tr>
<td>ASCII mode</td>
<td>K_XLATE</td>
<td>0x01</td>
<td>XLATE mode: Convert to TTY Code.</td>
</tr>

<tr>
<td>UTF-8 MODE</td>
<td>K_UNICODE</td>
<td>0x03</td>
<td>Unicode mode：Same as XLATE，external input UNICODE throw number keypad.</td>
</tr>
</tbody>
</table>

<h2 id="example">Example</h2>

<p>Here is an example of how to get and set keyboard mode.
At final, how to restore the keyboard mode.</p>
<pre><code>#include &lt;linux/kd.h&gt;
#include &lt;linux/key.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main() {
  long saved_mode;

  ioctl(STDIN_FILENO, KDGKBMODE, &amp;saved_mode);
  if (ioctl(STDIN_FILENO, KDSKBMODE, K_MEDIUMRAW) &lt; 0) {
    perror(&quot;set keyboard to mediuraw mode fail:&quot;);
    exit (EXIT_FAILURE);
  }

  /* 
   * do something... 
   */

  return ioctl(STDIN_FILENO, KDSKBMODE, saved_mode);
}
</code></pre>

<h1 id="2-terminal-interface">2. Terminal Interface</h1>

<p>POSIX systems support two basic modes of input: canonical and noncanonical. [2]</p>

<p>In canonical input processing mode,
terminal input is processed in lines terminated by newline (’\n’), EOF, or EOL characters.
No input can be read until an entire line has been typed by the user,
and the read function returns at most a single line of input,
no matter how many bytes are requested.</p>

<p>In canonical input mode, the operating system provides input editing facilities:
some characters are interpreted specially to perform editing operations
within the current line of text, such as ERASE and KILL.</p>

<p>In noncanonical input processing mode, characters are not grouped into lines, and
ERASE and KILL processing is not performed. The granularity with which bytes are read in
noncanonical input mode is controlled by the MIN and TIME settings.</p>

<p>Most programs use canonical input mode, because this gives the user a way to edit
input line by line. The usual reason to use noncanonical mode is when the program accepts
single-character commands or provides its own editing facilities.</p>

<h2 id="terminal-modes">Terminal modes</h2>

<p>This section describes the various terminal attributes that control how input and output
are done. The functions, data structures, and symbolic constants are all declared in the
header file ‘termios.h’.</p>

<p>The entire collection of attributes of a terminal is stored in a structure of type <em>struct
termios</em>. This structure is used with the functions <em>tcgetattr</em> and <em>tcsetattr</em> to read and
set the attributes.</p>

<table>
<thead>
<tr>
<th>data type</th>
<th>name</th>
<th>remark</th>
</tr>
</thead>

<tbody>
<tr>
<td>tcflag_t</td>
<td>c_iflag</td>
<td>A bit mask specifying flags for input modes;</td>
</tr>

<tr>
<td>tcflag_t</td>
<td>c_oflag</td>
<td>A bit mask specifying flags for output modes;</td>
</tr>

<tr>
<td>tcflag_t</td>
<td>c_cflag</td>
<td>A bit mask specifying flags for control modes;</td>
</tr>

<tr>
<td>tcflag_t</td>
<td>c_lflag</td>
<td>A bit mask specifying flags for local modes;</td>
</tr>

<tr>
<td>cc_t</td>
<td>c_cc[NCCS]</td>
<td>An array specifying which characters are associated with various control functions;</td>
</tr>
</tbody>
</table>

<p><strong>tcflag_t</strong> This is an unsigned integer type used to represent the various bit masks for terminal
flags.</p>

<p><strong>cc_t</strong> This is an unsigned integer type used to represent characters associated with various
terminal control functions.</p>

<h2 id="terminal-model-functions">Terminal Model functions</h2>
<pre><code>int tcgetattr (int filedes, struct termios *termios-p)
</code></pre>

<p>This function is used to examine the attributes of the terminal device with file descriptor
filedes. The attributes are returned in the structure that <em>termios-p</em> points to.</p>

<p>If successful, <strong>tcgetattr</strong> returns 0. A return value of <strong>-1</strong> indicates an error.
The following <em>errno</em> error conditions are defined for this function:</p>

<p><strong>EBADF</strong> The filedes argument is not a valid file descriptor.</p>

<p><strong>ENOTTY</strong> The filedes is not associated with a terminal.</p>
<pre><code>int tcsetattr (int filedes, int when, const struct termios *termios-p)
</code></pre>

<p>This function sets the attributes of the terminal device with file descriptor filedes.
The new attributes are taken from the structure that <em>termios-p</em> points to.
The when argument specifies how to deal with input and output already queued. It
can be one of the following values:</p>

<table>
<thead>
<tr>
<th>when</th>
<th>Remark</th>
</tr>
</thead>

<tbody>
<tr>
<td>TCSANOW</td>
<td>Make the change immediately.</td>
</tr>

<tr>
<td>TCSADRAIN</td>
<td>Make the change after waiting until all queued output has been written. You should usually use this option when changing parameters that affect output.</td>
</tr>

<tr>
<td>TCSAFLUSH</td>
<td>This is like TCSADRAIN, but also discards any queued input.</td>
</tr>

<tr>
<td>TCSASOFT</td>
<td>This is a flag bit that you can add to any of the above alternatives. Its meaning is to inhibit alteration of the state of the terminal hardware. It is a BSD extension; it is only supported on BSD systems and the GNU system. <br>Using TCSASOFT is exactly the same as setting the CIGNORE it in the c_cflag member of the structure <em>termios-p</em> points to.</td>
</tr>
</tbody>
</table>

<p>If this function is called from a background process on its controlling terminal,
normally all processes in the process group are sent a SIGTTOU signal, in the same way
as if the process were trying to write to the terminal. The exception is if the calling
process itself is ignoring or blocking SIGTTOU signals, in which case the operation is
performed and no signal is sent.</p>

<p>If successful, tcsetattr returns 0. A return value of -1 indicates an error. The
following errno error conditions are defined for this function:</p>

<p><strong>EBADF</strong> The filedes argument is not a valid file descriptor.</p>

<p><strong>ENOTTY</strong> The filedes is not associated with a terminal.</p>

<p><strong>EINVAL</strong> Either the value of the when argument is not valid, or there is something
wrong with the data in the termios-p argument.</p>

<p>Although <strong>tcgetattr</strong> and <strong>tcsetattr</strong> specify the terminal device with a file descriptor,
the attributes are those of the terminal device itself and not of the file descriptor. This
means that the effects of changing terminal attributes are persistent; if another process
opens the terminal file later on, it will see the changed attributes even though it doesn’t
have anything to do with the open file descriptor you originally specified in changing the
attributes.</p>

<p>Similarly, if a single process has multiple or duplicated file descriptors for the same
terminal device, changing the terminal attributes affects input and output to all of these
file descriptors. This means, for example, that you can’t open one file descriptor or stream
to read from a terminal in the normal line-buffered, echoed mode; and simultaneously
have another file descriptor for the same terminal that you use to read from it in singlecharacter,
non-echoed mode. Instead, you have to explicitly switch the terminal back and
forth between the two modes.</p>

<h2 id="set-up-terminal-mode">Set up Terminal Mode</h2>

<p>When you set terminal modes, you should call <strong>tcgetattr</strong> first to get the current modes of
the particular terminal device, modify only those modes that you are really interested in,
and store the result with <strong>tcsetattr</strong>.</p>

<p>It’s a bad idea to simply initialize a struct <em>termios</em> structure to a chosen set of attributes
and pass it directly to tcsetattr. Your program may be run years from now, on
systems that support members not documented in this manual. The way to avoid setting
these members to unreasonable values is to avoid changing them.</p>

<p>What’s more, different terminal devices may require different mode settings in order to
function properly. So you should avoid blindly copying attributes from one terminal device
to another.</p>

<p>When a member contains a collection of independent flags, as the c_iflag, c_oflag
and c_cflag members do, even setting the entire member is a bad idea, because particular
operating systems have their own flags. Instead, you should start with the current value
of the member and alter only the flags whose values matter in your program, leaving any
other flags unchanged.</p>

<h3 id="input-mode">Input Mode</h3>

<p>This section describes the terminal attribute flags that control fairly low-level aspects of
input processing: handling of parity errors, break signals, flow control, and RET and LFD
characters.</p>

<p>All of these flags are bits in the <strong>c_iflag</strong> member of the <em>struct termios</em> structure. The
member is an integer, and you change flags using the operators &amp;, | and ^. Don’t try to
specify the entire value for <strong>c_iflag</strong>—instead, change only specific flags and leave the rest
untouched.</p>

<table>
<thead>
<tr>
<th>flag name</th>
<th>remark</th>
</tr>
</thead>

<tbody>
<tr>
<td>INPCK</td>
<td>If this bit is set, input parity checking is enabled. If it is not set, no checking at all is done for parity errors on input; the characters are simply passed through to the application. <br>Parity checking on input processing is independent of whether parity detection and generation on the underlying terminal hardware is enabled; <br>For example, you could clear the <strong>INPCK</strong> input mode flag and set the PARENB control mode flag to ignore parity errors on input, but still generate parity on output. <br>If this bit is set, what happens when a parity error is detected depends on whether the <strong>IGNPAR</strong> or <strong>PARMRK</strong> bits are set. If neither of these bits are set, a byte with a parity error is passed to the application as a ’\0’ character.</td>
</tr>

<tr>
<td>IGNPAR</td>
<td>If this bit is set, any byte with a framing or parity error is ignored. This is only useful if <strong>INPCK</strong> is also set.</td>
</tr>

<tr>
<td>PARMRK</td>
<td>If this bit is set, input bytes with parity or framing errors are marked when passed to the program. This bit is meaningful only when <strong>INPCK</strong> is set and <strong>IGNPAR</strong> is not set. The way erroneous bytes are marked is with two preceding bytes, 377 and 0. Thus, the program actually reads three bytes for one erroneous byte received from the terminal.<br>If a valid byte has the value 0377, and <strong>ISTRIP</strong> (see below) is not set, the program might confuse it with the prefix that marks a parity error. So a valid byte 0377 is passed to the program as two bytes, 0377 0377, in this case.</td>
</tr>

<tr>
<td>ISTRIP</td>
<td>If this bit is set, valid input bytes are stripped to seven bits; otherwise, all eight bits are available for programs to read.</td>
</tr>

<tr>
<td>IGNBRK</td>
<td>If this bit is set, break conditions are ignored. A break condition is defined in the context of asynchronous serial data transmission as a series of zero-value bits longer than a single byte.</td>
</tr>

<tr>
<td>BRKINT</td>
<td>If this bit is set and IGNBRK is not set, a break condition clears the terminal input and output queues and raises a SIGINT signal for the foreground process group associatedwith the terminal.<br>If neither BRKINT nor IGNBRK are set, a break condition is passed to the application as a single ’\0’ character if PARMRK is not set, or otherwise as a three-character sequence ’\377’, ’\0’, ’\0’.</td>
</tr>

<tr>
<td>IGNCR</td>
<td>If this bit is set, carriage return characters (’\r’) are discarded on input. Discarding carriage return may be useful on terminals that send both carriage return and linefeed when you type the RET key.</td>
</tr>

<tr>
<td>ICRNL</td>
<td>If this bit is set and IGNCR is not set, carriage return characters (’\r’) received as input are passed to the application as newline characters (’\n’).</td>
</tr>

<tr>
<td>INLCR</td>
<td>If this bit is set, newline characters (’\n’) received as input are passed to the application as carriage return characters (’\r’).</td>
</tr>

<tr>
<td>IXOFF</td>
<td>If this bit is set, start/stop control on input is enabled. In other words, the computer sends STOP and START characters as necessary to prevent input from coming in faster than programs are reading it. The idea is that the actual terminal hardware that is generating the input data responds to a STOP character by suspending transmission, and to a START character by resuming transmission.</td>
</tr>

<tr>
<td>IXON</td>
<td>If this bit is set, start/stop control on output is enabled. In other words, if the computer receives a STOP character, it suspends output until a START character is received. In this case, the STOP and START characters are never passed to the application program. If this bit is not set, then START and STOP can be read as ordinary characters.</td>
</tr>

<tr>
<td>IXANY</td>
<td>If this bit is set, any input character restarts output when output has been suspended with the STOP character. Otherwise, only the START character restarts output. This is a BSD extension; it exists only on BSD systems and the GNU system.</td>
</tr>

<tr>
<td>IMAXBEL</td>
<td>If this bit is set, then filling up the terminal input buffer sends a BEL character (code 007) to the terminal to ring the bell.This is a BSD extension.</td>
</tr>
</tbody>
</table>

<h3 id="output-mode">Output Mode</h3>

<p>This section describes the terminal flags and fields that control how output characters are
translated and padded for display. All of these are contained in the c_oflag member of the
struct termios structure.</p>

<p>The <em>c_oflag</em> member itself is an integer, and you change the flags and fields using the
operators &amp;, |, and ^. Don’t try to specify the entire value for c_oflag—instead, change
only specific flags and leave the rest untouched.</p>

<table>
<thead>
<tr>
<th>flag name</th>
<th>remark</th>
</tr>
</thead>

<tbody>
<tr>
<td>OPOST</td>
<td>If this bit is set, output data is processed in some unspecified way so that it is displayed appropriately on the terminal device. This typically includes mapping newline characters (’\n’) onto carriage return and linefeed pairs.<br>If this bit isn’t set, the characters are transmitted as-is. The following three bits are BSD features, and they exist only BSD systems and the GNU system. They are effective only if OPOST is set.</td>
</tr>

<tr>
<td>ONLCR</td>
<td>If this bit is set, convert the newline character on output into a pair of characters, carriage return followed by linefeed.</td>
</tr>

<tr>
<td>OXTABS</td>
<td>If this bit is set, convert tab characters on output into the appropriate number of spaces to emulate a tab stop every eight columns.</td>
</tr>

<tr>
<td>ONOEOT</td>
<td>If this bit is set, discard C-d characters (code 004) on output. These characters cause many dial-up terminals to disconnect.</td>
</tr>
</tbody>
</table>

<h3 id="control-modes">Control Modes</h3>

<p>This section describes the terminal flags and fields that control parameters usually associated
with asynchronous serial data transmission. These flags may not make sense for other
kinds of terminal ports (such as a network connection pseudo-terminal). All of these are
contained in the c_cflag member of the struct termios structure.</p>

<p>The c_cflag member itself is an integer, and you change the flags and fields using the
operators &amp;, |, and ^. Don’t try to specify the entire value for c_cflag—instead, change
only specific flags and leave the rest untouched.</p>

<table>
<thead>
<tr>
<th>flag name</th>
<th>remark</th>
</tr>
</thead>

<tbody>
<tr>
<td>CLOCAL</td>
<td>If this bit is set, it indicates that the terminal is connected “locally” and that the modem status lines (such as carrier detect) should be ignored.<br> On many systems if this bit is not set and you call open without the O_NONBLOCK flag set, open blocks until a modem connection is established.<br>If this bit is not set and a modem disconnect is detected, a SIGHUP signal is sent to the controlling process group for the terminal (if it has one). Normally, this causes the process to exit; see Chapter 24 [Signal Handling], page 590. Reading from the terminal after a disconnect causes an end-of-file condition, and writing causes an EIO error to be returned. The terminal device must be closed and reopened to clear the condition.</td>
</tr>

<tr>
<td>HUPCL</td>
<td>If this bit is set, a modem disconnect is generated when all processes that have the terminal device open have either closed the file or exited.</td>
</tr>

<tr>
<td>CREAD</td>
<td>If this bit is set, input can be read from the terminal. Otherwise, input is discarded when it arrives.</td>
</tr>

<tr>
<td>CSTOPB</td>
<td>If this bit is set, two stop bits are used. Otherwise, only one stop bit is used.</td>
</tr>

<tr>
<td>PARENB</td>
<td>If this bit is set, generation and detection of a parity bit are enabled. See <strong>Input Modes</strong> for information on how input parity errors are handled. If this bit is not set, no parity bit is added to output characters, and input characters are not checked for correct parity.</td>
</tr>

<tr>
<td>PARODD</td>
<td>This bit is only useful if PARENB is set. If PARODD is set, odd parity is used, otherwiseeven parity is used.<br>The control mode flags also includes a field for the number of bits per character. You can use the CSIZE macro as a mask to extract the value, like this: settings.c_cflag &amp; CSIZE.</td>
</tr>

<tr>
<td>CSIZE</td>
<td>This is a mask for the number of bits per character.</td>
</tr>

<tr>
<td>CS5</td>
<td>This specifies five bits per byte.</td>
</tr>

<tr>
<td>CS6</td>
<td>This specifies six bits per byte.</td>
</tr>

<tr>
<td>CS7</td>
<td>This specifies seven bits per byte.</td>
</tr>

<tr>
<td>CS8</td>
<td>This specifies eight bits per byte.</td>
</tr>
</tbody>
</table>

<h3 id="local-modes">Local Modes</h3>

<p>This section describes the flags for the c_lflag member of the struct termios structure.
These flags generally control higher-level aspects of input processing than the input modes
flags described in Section <strong>Input Modes</strong>, such as echoing, signals, and the
choice of canonical or noncanonical input.</p>

<p>The c_lflag member itself is an integer, and you change the flags and fields using the
operators &amp;, |, and ^. Don’t try to specify the entire value for c_lflag—instead, change
only specific flags and leave the rest untouched.</p>

<table>
<thead>
<tr>
<th>flag name</th>
<th>remark</th>
</tr>
</thead>

<tbody>
<tr>
<td>ICANON</td>
<td>This bit, if set, enables canonical input processing mode. Otherwise, input is processed in noncanonical mode.</td>
</tr>

<tr>
<td>ECHO</td>
<td>If this bit is set, echoing of input characters back to the terminal is enabled.</td>
</tr>

<tr>
<td>ECHOE</td>
<td>If this bit is set, echoing indicates erasure of input with the ERASE character by erasing the last character in the current line from the screen. Otherwise, the character erased is re-echoed to show what has happened (suitable for a printing terminal).<br> This bit only controls the display behavior; the ICANON bit by itself controls actual recognition of the ERASE character and erasure of input, without which ECHOE is simply irrelevant.</td>
</tr>

<tr>
<td>ECHOPRT</td>
<td>This bit is like ECHOE, enables display of the ERASE character in a way that is geared to a hardcopy terminal. When you type the ERASE character, a ‘\’ character is printed followed by the first character erased. Typing the ERASE character again just prints the next character erased. Then, the next time you type a normal character, a ‘/’ character is printed before the character echoes.<br>This is a BSD extension, and exists only in BSD systems and the GNU system.</td>
</tr>

<tr>
<td>ECHOK</td>
<td>This bit enables special display of the KILL character by moving to a new line after echoing the KILL character normally. The behavior of ECHOKE (below) is nicer to look at.<br> If this bit is not set, the KILL character echoes just as it would if it were not the KILL character. Then it is up to the user to remember that the KILL character has erased the preceding input; there is no indication of this on the screen. This bit only controls the display behavior; the ICANON bit by itself controls actual recognition of the KILL character and erasure of input, without which ECHOK is simply irrelevant.</td>
</tr>

<tr>
<td>ECHOKE</td>
<td>This bit is similar to ECHOK. It enables special display of the KILL character by erasing on the screen the entire line that has been killed. This is a BSD extension, and exists only in BSD systems and the GNU system.</td>
</tr>

<tr>
<td>ECHONL</td>
<td>If this bit is set and the ICANON bit is also set, then the newline (’\n’) character isechoed even if the ECHO bit is not set.</td>
</tr>

<tr>
<td>ECHOCTL</td>
<td>If this bit is set and the ECHO bit is also set, echo control characters with ‘^’ followed by the corresponding text character. Thus, control-A echoes as ‘^A’. This is usually the preferred mode for interactive input, because echoing a control character back to the terminal could have some undesired effect on the terminal.<br>This is a BSD extension, and exists only in BSD systems and the GNU system.</td>
</tr>

<tr>
<td>ISIG</td>
<td>This bit controls whether the INTR, QUIT, and SUSP characters are recognized. The functions associated with these characters are performed if and only if this bit is set. Being in canonical or noncanonical input mode has no affect on the interpretation of these characters.<br> You should use caution when disabling recognition of these characters. Programs that cannot be interrupted interactively are very user-unfriendly. If you clear this bit, your program should provide some alternate interface that allows the user to interactively send the signals associated with these characters, or to escape from the program.</td>
</tr>

<tr>
<td>IEXTEN</td>
<td>POSIX.1 gives IEXTEN implementation-defined meaning, so you cannot rely on this interpretation on all systems.<br>On BSD systems and the GNU system, it enables the LNEXT and DISCARD characters.</td>
</tr>

<tr>
<td>NOFLSH</td>
<td>Normally, the INTR, QUIT, and SUSP characters cause input and output queues for the terminal to be cleared. If this bit is set, the queues are not cleared.</td>
</tr>

<tr>
<td>TOSTOP</td>
<td>If this bit is set and the system supports job control, then SIGTTOU signals are generatedby background processes that attempt to write to the terminal.<br>The following bits are BSD extensions; they exist only in BSD systems and the GNU system.</td>
</tr>

<tr>
<td>ALTWERASE</td>
<td>This bit determines how far the WERASE character should erase. The WERASE character erases back to the beginning of a word; the question is, where do words begin?<br>If this bit is clear, then the beginning of a word is a nonwhitespace character following a whitespace character. If the bit is set, then the beginning of a word is an alphanumeric character or underscore following a character which is none of those.</td>
</tr>

<tr>
<td>FLUSHO</td>
<td>This is the bit that toggles when the user types the DISCARD character. While this bit is set, all output is discarded.</td>
</tr>

<tr>
<td>NOKERNINFO</td>
<td>Setting this bit disables handling of the STATUS character.</td>
</tr>

<tr>
<td>PENDIN</td>
<td>If this bit is set, it indicates that there is a line of input that needs to be reprinted. Typing the REPRINT character sets this bit; the bit remains set until reprinting is finished.</td>
</tr>
</tbody>
</table>

<h3 id="noncanonical-input">Noncanonical Input</h3>

<p>In noncanonical input mode, the special editing characters such as ERASE and KILL are
ignored. The system facilities for the user to edit input are disabled in noncanonical mode,
so that all input characters (unless they are special for signal or flow-control purposes) are
passed to the application program exactly as typed. It is up to the application program to
give the user ways to edit the input, if appropriate.</p>

<p>Noncanonical mode offers special parameters called MIN and TIME for controlling
whether and how long to wait for input to be available. You can even use them to avoid
ever waiting—to return immediately with whatever input is available, or with no input.
The MIN and TIME are stored in elements of the <strong>c_cc</strong> array, which is a member of
the struct termios structure. Each element of this array has a particular role, and each
element has a symbolic constant that stands for the index of that element. VMIN and VMAX
are the names for the indices in the array of the <strong>MIN</strong> and <strong>TIME</strong> slots.</p>

<h4 id="int-vmin">int VMIN</h4>

<p>This is the subscript for the MIN slot in the c_cc array. Thus, termios.c_cc[VMIN]
is the value itself.</p>

<p>The MIN slot is only meaningful in noncanonical input mode; it specifies the minimum
number of bytes that must be available in the input queue in order for read to return.</p>

<h4 id="int-vtime">int VTIME</h4>

<p>This is the subscript for the TIME slot in the c<em>cc array. Thus, termios.c</em>
cc[VTIME] is the value itself.</p>

<p>The TIME slot is only meaningful in noncanonical input mode; it specifies how long
to wait for input before returning, in units of 0.1 seconds.
The MIN and TIME values interact to determine the criterion for when read should
return; their precise meanings depend on which of them are nonzero. There are four possible
cases:</p>

<h4 id="both-time-and-min-are-nonzero">Both TIME and MIN are nonzero.</h4>

<p>In this case, TIME specifies how long to wait after each input character to see if more
input arrives. After the first character received, read keeps waiting until either MIN
bytes have arrived in all, or TIME elapses with no further input.
read always blocks until the first character arrives, even if TIME elapses first. read
can return more than MIN characters if more than MIN happen to be in the queue.</p>

<h4 id="both-min-and-time-are-zero"> Both MIN and TIME are zero.</h4>

<p>In this case, read always returns immediately with as many characters as are available
in the queue, up to the number requested. If no input is immediately available, read
returns a value of zero.</p>

<h4 id="min-is-zero-but-time-has-a-nonzero-value">MIN is zero but TIME has a nonzero value.</h4>

<p>In this case, read waits for time TIME for input to become available; the availability
of a single byte is enough to satisfy the read request and cause read to return. When
it returns, it returns as many characters as are available, up to the number requested.
If no input is available before the timer expires, read returns a value of zero.</p>

<h4 id="time-is-zero-but-min-has-a-nonzero-value">TIME is zero but MIN has a nonzero value.</h4>

<p>In this case, read waits until at least MIN bytes are available in the queue. At that
time, read returns as many characters as are available, up to the number requested.
read can return more than MIN characters if more than MIN happen to be in the
queue.</p>

<p>What happens if MIN is 50 and you ask to read just 10 bytes? Normally, read waits until
there are 50 bytes in the buffer (or, more generally, the wait condition described above is
satisfied), and then reads 10 of them, leaving the other 40 buffered in the operating system
for a subsequent call to read.</p>

<p>Portability note: On some systems, the MIN and TIME slots are actually the same as
the EOF and EOL slots. This causes no serious problem because the MIN and TIME slots
are used only in noncanonical input and the EOF and EOL slots are used only in canonical
input, but it isn’t very clean. The GNU library allocates separate slots for these uses.</p>

<h2 id="noncanonical-mode-example">Noncanonical Mode Example</h2>
<pre><code>#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;termios.h&gt;

/* Use this variable to remember original terminal attributes. */
struct termios saved_attributes;
void reset_input_mode(void) {
  tcsetattr(STDIN_FILENO, TCSANOW, &amp;saved_attributes);
}

void set_input_mode(void) {
  struct termios tattr;
  char *name;
  /* Make sure stdin is a terminal. */
  if (!isatty(STDIN_FILENO)) {
    fprintf (stderr, &quot;Not a terminal.\n&quot;);
    exit (EXIT_FAILURE);
  }
  /* Save the terminal attributes so we can restore them later. */
  tcgetattr(STDIN_FILENO, &amp;saved_attributes);
  atexit(reset_input_mode);
  /* Set the funny terminal modes. */
  tcgetattr(STDIN_FILENO, &amp;tattr);
  tattr.c_lflag &amp;= ~(ICANON|ECHO); /* Clear ICANON and ECHO. */
  tattr.c_cc[VMIN] = 1;
  tattr.c_cc[VTIME] = 0;
  tcsetattr(STDIN_FILENO, TCSAFLUSH, &amp;tattr);
}

int main(void) {
  char c;
  set_input_mode();
  while (1) {
    read(STDIN_FILENO, &amp;c, 1);
    if (c == ’\004’) break;  /* C-d */ 
    else putchar (c);
  }
  return EXIT_SUCCESS;
}
</code></pre>

<h1 id="references">REFERENCES</h1>

<p>[1] Console_ioctl(4). <a href="http://man7.org/linux/man-pages/man4/console_ioctl.4.html">http://man7.org/linux/man-pages/man4/console_ioctl.4.html</a></p>

<p>[2] Richard M. Stallman, Roland McGrath. The GNU C Library Reference Manual version 2.8. 17:433-455, 2007-10-27.</p>
</section>
                        <aside class="aside clearfix">
                            <a class="btn btn-primary btn-lg pull-right" href="/2016/10/28/Linux-Terminal-Programming.html">Read More</a>
                        </aside>
                    </div>
                </div>
            </article>
            
            <article class="article">
                <div class="row">
                    <div class="col-md-10 col-md-offset-1 panel panel-default">
                        <header class="header">
                            <div class="meta">
                        <span class="date">
                            <span class="month">10</span>
                            <span class="day">26</span>
                        </span>
                            </div>
                            <h3 class="title">
                                <a href="/2016/10/26/Set-Up-Git-Server-With-SSH.html">Set Up Git Server With SSH</a>
                            </h3>
                        </header>
                        <section class="brief"><p>This Document is a copy of <a href="https://www.google.com/search?hl=zh-CN&amp;q=markdown">Git on the Server - Setting Up the Server</a></p>

<h1 id="setting-up-server">Setting Up Server</h1>

<p>Let’s walk through setting up SSH access on the server side.
In this example, you’ll use the authorized_keys method for authenticating your users.
We also assume you’re running a standard Linux distribution like Ubuntu.
First, you create a git user and a .ssh directory for that user.</p>
<pre><code>$ sudo adduser git
$ su git
$ cd
$ mkdir .ssh &amp;&amp; chmod 700 .ssh
$ touch .ssh/authorized_keys &amp;&amp; chmod 600 .ssh/authorized_keys
</code></pre>

<p>Next, you need to add some developer SSH public keys to the authorized_keys file for the git user.
Let’s assume you have some trusted public keys and have saved them to temporary files.
Again, the public keys look something like this:</p>
<pre><code>$ cat /tmp/id_rsa.pub
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCB007n/ww+ouN4gSLKssMxXnBOvf9LGt4L
ojG6rs6hPB09j9R/T17/x4lhJA0F3FR1rP6kYBRsWj2aThGw6HXLm9/5zytK6Ztg3RPKK+4k
Yjh6541NYsnEAZuXz0jTTyAUfrtU3Z5E003C4oxOj6H0rfIF1kKI9MAQLMdpGW1GYEIgS9Ez
Sdfd8AcCIicTDWbqLAcU4UpkaX8KyGlLwsNuuGztobF8m72ALC/nLF6JLtPofwFBlgc+myiv
O7TCUSBdLQlgMVOFq1I2uPWQOkOWQAHukEOmfjy2jctxSDBQ220ymjaNsHT4kgtZg2AYYgPq
dAv8JggJICUvax2T9va5 gsg-keypair
</code></pre>

<p>You just append them to the git user’s authorized_keys file in its .ssh directory:</p>

<p>$ cat /tmp/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</p>

<p>Now, you can set up an empty repository for them by running git init with the --bare option,
which initializes the repository without a working directory:</p>
<pre><code>$ cd /opt/git
$ mkdir project.git
$ cd project.git
$ git init --bare
Initialized empty Git repository in /opt/git/project.git
</code></pre>

<p>At last, you can clone it down and push changes back up just as easily:</p>
<pre><code>$ git clone git@gitserver:/opt/git/project.git
$ cd project
$ vim README
$ git commit -am 'fix for the README file'
$ git push origin master
</code></pre>

<p>With this method, you can quickly get a read/write Git server up and running
for a handful of developers.</p>

<h1 id="forbidden-login">Forbidden login</h1>

<p>You should note that currently all these users can also log into the server and
get a shell as the git user.
If you want to restrict that,
you will have to change the shell to something else in the passwd file.</p>

<p>You can easily restrict the git user to only doing Git activities
with a limited shell tool called git-shell that comes with Git.
If you set this as your git user’s login shell,
then the git user can’t have normal shell access to your server.
To use this, specify git-shell instead of bash or csh for your user’s login shell.
To do so, you must first add git-shell to /etc/shells if it’s not already there:</p>
<pre><code>$ cat /etc/shells   # see if `git-shell` is already in there.  If not...
$ which git-shell   # make sure git-shell is installed on your system.
$ sudo vim /etc/shells  # and add the path to git-shell from last command
</code></pre>

<p>Now you can edit the shell for a user using chsh <username>:</p>
<pre><code>$ sudo chsh git  # and enter the path to git-shell, usually: /usr/bin/git-shell
</code></pre>

<p>Now, the git user can only use the SSH connection to push and
pull Git repositories and can’t shell onto the machine.
If you try, you’ll see a login rejection like this:</p>
<pre><code>$ ssh git@gitserver
fatal: Interactive git shell is not enabled.
hint: ~/git-shell-commands should exist and have read and execute access.
Connection to gitserver closed.
</code></pre>

<p>Now Git network commands will still work just fine but the users won’t be able to get a shell.
As the output states,
you can also set up a directory in the git user’s home directory
that customizes the git-shell command a bit.
For instance,
you can restrict the Git commands that the server will accept
or you can customize the message that users see
if they try to SSH in like that.
Run git help shell for more information on customizing the shell.</p>
</section>
                        <aside class="aside clearfix">
                            <a class="btn btn-primary btn-lg pull-right" href="/2016/10/26/Set-Up-Git-Server-With-SSH.html">Read More</a>
                        </aside>
                    </div>
                </div>
            </article>
            
            <article class="article">
                <div class="row">
                    <div class="col-md-10 col-md-offset-1 panel panel-default">
                        <header class="header">
                            <div class="meta">
                        <span class="date">
                            <span class="month">10</span>
                            <span class="day">25</span>
                        </span>
                            </div>
                            <h3 class="title">
                                <a href="/2016/10/25/vim-notes.html">vim notes</a>
                            </h3>
                        </header>
                        <section class="brief"><p>记录一些网上收集的VIM的使用手册及知识点</p>

<h1 id="宏命令相关">宏命令相关</h1>
<pre><code>:qx 开始记录宏，并将结果存入寄存器x
q 退出记录模式
@x 播放记录在x寄存器中的宏命令
</code></pre>

<p>稍微解释一下，当在normal模式下输入:qx后，你对文本的所有编辑动作将会被记录下来，再次输入q即退出了记录模
式，然后输入@x对刚才记录下来的命令进行重复，此命令后可跟数字，表示要重复多少次，比如@x20，可以重复20次。这个在文本的批处理中是非常有用的。</p>

<h1 id="标签命令">标签命令</h1>

<p>在vim众多的插件中，有一个叫minibuffer的插件，就是下面所说的标签页功能了，可以支持同时编辑多个文件。</p>
<pre><code>当你把光标置于这个窗口时, 有下面几个快捷键可以用:
向前循环切换到每个buffer名上
向后循环切换到每个buffer名上
在打开光标所在的buffer
d 删除光标所在的buffer
</code></pre>

<h1 id="命令模式">命令模式</h1>
<pre><code>:tabe fn 在一个新的标签页中编辑文件fn
gt 切换到下一个标签页
gT 切换到上一个标签页
:tabr 切换到第一个标签页
:tabl 切换到最后一个标签页
:tabm [N] 把当前tab移动到第N个tab之后

:e file 把file加载到新的缓冲区中
:bn 打开当前buffer的下一个buffer
:bp 打开当前buffer的前一个buffer
:b”num” 打开指定的buffer，”num”指的是buffer开始的那个数字，比如上图，我想打开list_audit.erb，输入:b7就ok了
:bd 删除缓冲区(关闭文件)

:sp fn 分割窗口，并将fn加载到新的窗口中
</code></pre>

<h1 id="退出编辑器">退出编辑器</h1>
<pre><code>:w 将缓冲区写入文件，即保存修改
:wq 保存修改并退出
:x 保存修改并退出
:q 退出，如果对缓冲区进行过修改，则会提示
:q! 强制退出，放弃修改
</code></pre>

<h1 id="查找替换">查找替换</h1>
<pre><code>/pattern 向后搜索字符串pattern
?pattern 向前搜索字符串pattern
n 下一个匹配(如果是/搜索，则是向下的下一个，?搜索则是向上的下一个)
N 上一个匹配(同上)
:%s/old/new/g 搜索整个文件，将所有的old替换为new
:%s/old/new/gc 搜索整个文件，将所有的old替换为new，每次都要你确认是否替换
</code></pre>

<h1 id="复制粘贴">复制粘贴</h1>
<pre><code>dd 删除光标所在行
dw 删除一个字(word)
x 删除当前字符
X 删除前一个字符
D 删除到行末
yy 复制一行，此命令前可跟数字，标识复制多行，如6yy，表示从当前行开始复制6行
yw 复制一个字
y$ 复制到行末
p 粘贴粘贴板的内容到当前行的下面
P 粘贴粘贴板的内容到当前行的上面
]p 有缩进的粘贴，vim会自动调节代码的缩进
“a 将内容放入/存入a寄存器，可以支持多粘贴板
</code></pre>

<p>附：比如常用的一个寄存器就是系统寄存器，名称为+，所以从系统粘贴板粘贴到vim中的命令为”+p,注意此处的+不表示操作符，二十一个寄存器。</p>

<h1 id="移动光标">移动光标</h1>

<p>在vim中移动光标跟其他的编辑器中有很大的区别，不过一旦学会了，就会飞速的在文本中移动了。</p>
<pre><code>h,j,k,l 上，下，左，右
ctrl-f 上翻一页
ctrl-b 下翻一页
% 跳到与当前括号匹配的括号处，如当前在{，则跳转到与之匹配的}处
w 跳到下一个字首，按标点或单词分割
W 跳到下一个字首，长跳，如end-of-line被认为是一个字
e 跳到下一个字尾
E 跳到下一个字尾，长跳
b 跳到上一个字
B 跳到上一个字，长跳
0 跳至行首，不管有无缩进，就是跳到第0个字符
^ 跳至行首的第一个字符
$ 跳至行尾
gg 跳至文件的第一行
gd 跳至当前光标所在的变量的声明处
[N]G 跳到第N行，如0G，就等价于gg，100G就是第100行
fx 在当前行中找x字符，找到了就跳转至
; 重复上一个f命令，而不用重复的输入fx
tx 与fx类似，但是只是跳转到x的前一个字符处
Fx 跟fx的方向相反
),( 跳转到上/下一个语句
* 查找光标所在处的单词，向下查找
# 查找光标所在处的单词，向上查找
`. 跳转至上次编辑位置
在屏幕上移动

H 移动光标到当前屏幕上最上边的一行
M 移动光标到当前屏幕上中间的一行
L 移动光标到当前屏幕上最下边的一行
</code></pre>

<h1 id="书签">书签</h1>
<pre><code>ma 把当前位置存成标签a
`a 跳转到标签a处
</code></pre>

<h1 id="编辑">编辑</h1>
<pre><code>r 替换一个字符
J 将下一行和当前行连接为一行
cc 删除当前行并进入编辑模式
cw 删除当前字，并进入编辑模式
c$ 擦除从当前位置至行末的内容，并进入编辑模式
s 删除当前字符并进入编辑模式
S 删除光标所在行并进入编辑模式
xp 交换当前字符和下一个字符
u 撤销
ctrl+r 重做
. 重复上一个编辑命令
~ 切换大小写，当前字符
g~iw 切换当前字的大小写
gUiw 将当前字变成大写
guiw 将当前字变成小写
&gt;&gt; 将当前行右移一个单位
&lt;&lt; 将当前行左移一个单位(一个tab符)
== 自动缩进当前行
</code></pre>

<h1 id="插入模式">插入模式</h1>
<pre><code>i 从当前光标处进入插入模式
I 进入插入模式，并置光标于行首
a 追加模式，置光标于当前光标之后
A 追加模式，置光标于行末
o 在当前行之下新加一行，并进入插入模式
O 在当前行之上新加一行，并进入插入模式
Esc 退出插入模式
</code></pre>

<h1 id="可视模式">可视模式</h1>

<h2 id="标记文本">标记文本</h2>
<pre><code>v 进入可视模式，单字符模式
V 进入可视模式，行模式
ctrl+v 进入可视模式，列模式，类似于UE的列模式
o 跳转光标到选中块的另一个端点
U 将选中块中的内容转成大写
O 跳转光标到块的另一个端点
aw 选中一个字
ab 选中括号中的所有内容，包括括号本身
aB 选中{}括号中的所有内容
ib 选中括号中的内容，不含括号
iB 选中{}中的内容，不含{}
</code></pre>

<h2 id="对标记进行动作">对标记进行动作</h2>
<pre><code>&gt; 块右移
&lt; 块左移
y 复制块
d 删除块
~ 切换块中内容的大小写
</code></pre>

<h1 id="窗口命令">窗口命令</h1>
<pre><code>ctrl+w s 水平分割窗口
ctrl+w w 切换窗口
ctrl+w q 退出当前窗口(由于同时有多个文件，此命令不会影响其他窗口)
ctrl+w v 垂直分割窗口
CTRL-W = 使得所有窗口 (几乎) 等宽、等高，但当前窗口使用 ‘winheight’ 和 ‘winwidth’。

:res[ize] -N
CTRL-W – 使得当前窗口高度减 N (默认值是 1)。如果在 ‘vertical’ 之后使用，则使得宽度减 N。

:res[ize] +N
CTRL-W + 使得当前窗口高度加 N (默认值是 1)。如果在 ‘vertical’ 之后使用，则使得宽度加 N。

:res[ize] [N]
CTRL-W CTRL-_
CTRL-W _ 设置当前窗口的高度为 N (默认值为最大可能高度)。

:vertical res[ize] [N]
CTRL-W | 设置当前窗口的宽度为 N (默认值为最大可能宽度)。

z{nr}&lt;CR&gt; 设置当前窗口的高度为 {nr}。

CTRL-W &lt; 使得当前窗口宽度减 N (默认值是 1)。
CTRL-W &gt; 使得当前窗口宽度加 N (默认值是 1)。

&lt;整个窗口的移动&gt;
CTRL-W-H 将窗口移到最左边
CTRL-W-L 将窗口移到最右边
CTRL-W-J 将窗口移到底端
CTRL-W-K 将窗口移到顶端
</code></pre>
</section>
                        <aside class="aside clearfix">
                            <a class="btn btn-primary btn-lg pull-right" href="/2016/10/25/vim-notes.html">Read More</a>
                        </aside>
                    </div>
                </div>
            </article>
            
            <div class="article-pager text-center">
                
                
            </div>
        </div>
    </div>
</section>
<footer id="footer">
    <div class="container text-center">
        <p>© 2015 Zero Sky.
            <a href="http://creativecommons.org/licenses/by/3.0/">All rights reserved </a> |
            <a href="/feed.xml">Feed</a> |
            <a href="/sitemap.xml">Sitemap</a>
        </p>
        <p>Powered by <a href="https://github.com/go-xiaohei/pugo">PuGo 0.10.5 (beta)</a>. Theme by Default.
        </p>
        
    
    

    </div>
</footer>
<script src="/js/jquery-2.1.4.min.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/prism.min.js"></script>
<script>
    $(document).ready(function () {
        $("pre code").addClass("line-numbers")
    });
</script>
</body>
</html>
