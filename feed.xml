<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">
  <channel>
    <title>Zero Sky</title>
    <link>http://blog.90mark.com/</link>
    <description>PuGo is a Simple Static Site Generator</description>
    <managingEditor> (pugo)</managingEditor>
    <pubDate>Wed, 26 Oct 2016 06:16:04 -0700</pubDate>
    <item>
      <title>Set Up Git Server With SSH</title>
      <link>http://blog.90mark.com/2016/10/26/Set-Up-Git-Server-With-SSH.html</link>
      <description>&lt;p&gt;This Document is a copy of &lt;a href=&#34;https://www.google.com/search?hl=zh-CN&amp;amp;q=markdown&#34;&gt;Git on the Server - Setting Up the Server&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;setting-up-server&#34;&gt;Setting Up Server&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;Let’s walk through setting up SSH access on the server side.&#xA;In this example, you’ll use the authorized_keys method for authenticating your users.&#xA;We also assume you’re running a standard Linux distribution like Ubuntu.&#xA;First, you create a git user and a .ssh directory for that user.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ sudo adduser git&#xA;$ su git&#xA;$ cd&#xA;$ mkdir .ssh &amp;amp;&amp;amp; chmod 700 .ssh&#xA;$ touch .ssh/authorized_keys &amp;amp;&amp;amp; chmod 600 .ssh/authorized_keys&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Next, you need to add some developer SSH public keys to the authorized_keys file for the git user.&#xA;Let’s assume you have some trusted public keys and have saved them to temporary files.&#xA;Again, the public keys look something like this:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ cat /tmp/id_rsa.pub&#xA;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCB007n/ww+ouN4gSLKssMxXnBOvf9LGt4L&#xA;ojG6rs6hPB09j9R/T17/x4lhJA0F3FR1rP6kYBRsWj2aThGw6HXLm9/5zytK6Ztg3RPKK+4k&#xA;Yjh6541NYsnEAZuXz0jTTyAUfrtU3Z5E003C4oxOj6H0rfIF1kKI9MAQLMdpGW1GYEIgS9Ez&#xA;Sdfd8AcCIicTDWbqLAcU4UpkaX8KyGlLwsNuuGztobF8m72ALC/nLF6JLtPofwFBlgc+myiv&#xA;O7TCUSBdLQlgMVOFq1I2uPWQOkOWQAHukEOmfjy2jctxSDBQ220ymjaNsHT4kgtZg2AYYgPq&#xA;dAv8JggJICUvax2T9va5 gsg-keypair&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;You just append them to the git user’s authorized_keys file in its .ssh directory:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$ cat /tmp/id_rsa.pub &amp;gt;&amp;gt; ~/.ssh/authorized_keys&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, you can set up an empty repository for them by running git init with the --bare option,&#xA;which initializes the repository without a working directory:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ cd /opt/git&#xA;$ mkdir project.git&#xA;$ cd project.git&#xA;$ git init --bare&#xA;Initialized empty Git repository in /opt/git/project.git&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;At last, you can clone it down and push changes back up just as easily:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ git clone git@gitserver:/opt/git/project.git&#xA;$ cd project&#xA;$ vim README&#xA;$ git commit -am &#39;fix for the README file&#39;&#xA;$ git push origin master&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;With this method, you can quickly get a read/write Git server up and running&#xA;for a handful of developers.&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;forbidden-login&#34;&gt;Forbidden login&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;You should note that currently all these users can also log into the server and&#xA;get a shell as the git user.&#xA;If you want to restrict that,&#xA;you will have to change the shell to something else in the passwd file.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You can easily restrict the git user to only doing Git activities&#xA;with a limited shell tool called git-shell that comes with Git.&#xA;If you set this as your git user’s login shell,&#xA;then the git user can’t have normal shell access to your server.&#xA;To use this, specify git-shell instead of bash or csh for your user’s login shell.&#xA;To do so, you must first add git-shell to /etc/shells if it’s not already there:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ cat /etc/shells   # see if `git-shell` is already in there.  If not...&#xA;$ which git-shell   # make sure git-shell is installed on your system.&#xA;$ sudo vim /etc/shells  # and add the path to git-shell from last command&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Now you can edit the shell for a user using chsh &lt;username&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ sudo chsh git  # and enter the path to git-shell, usually: /usr/bin/git-shell&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Now, the git user can only use the SSH connection to push and&#xA;pull Git repositories and can’t shell onto the machine.&#xA;If you try, you’ll see a login rejection like this:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ ssh git@gitserver&#xA;fatal: Interactive git shell is not enabled.&#xA;hint: ~/git-shell-commands should exist and have read and execute access.&#xA;Connection to gitserver closed.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Now Git network commands will still work just fine but the users won’t be able to get a shell.&#xA;As the output states,&#xA;you can also set up a directory in the git user’s home directory&#xA;that customizes the git-shell command a bit.&#xA;For instance,&#xA;you can restrict the Git commands that the server will accept&#xA;or you can customize the message that users see&#xA;if they try to SSH in like that.&#xA;Run git help shell for more information on customizing the shell.&lt;/p&gt;&#xA;</description>
      <pubDate>Wed, 26 Oct 2016 05:22:21 +0000</pubDate>
    </item>
    <item>
      <title>vim notes</title>
      <link>http://blog.90mark.com/2016/10/25/vim-notes.html</link>
      <description>&lt;p&gt;记录一些网上收集的VIM的使用手册及知识点&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;宏命令相关&#34;&gt;宏命令相关&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;:qx 开始记录宏，并将结果存入寄存器x&#xA;q 退出记录模式&#xA;@x 播放记录在x寄存器中的宏命令&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;稍微解释一下，当在normal模式下输入:qx后，你对文本的所有编辑动作将会被记录下来，再次输入q即退出了记录模&#xA;式，然后输入@x对刚才记录下来的命令进行重复，此命令后可跟数字，表示要重复多少次，比如@x20，可以重复20次。这个在文本的批处理中是非常有用的。&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;标签命令&#34;&gt;标签命令&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;在vim众多的插件中，有一个叫minibuffer的插件，就是下面所说的标签页功能了，可以支持同时编辑多个文件。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;当你把光标置于这个窗口时, 有下面几个快捷键可以用:&#xA;向前循环切换到每个buffer名上&#xA;向后循环切换到每个buffer名上&#xA;在打开光标所在的buffer&#xA;d 删除光标所在的buffer&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1 id=&#34;命令模式&#34;&gt;命令模式&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;:tabe fn 在一个新的标签页中编辑文件fn&#xA;gt 切换到下一个标签页&#xA;gT 切换到上一个标签页&#xA;:tabr 切换到第一个标签页&#xA;:tabl 切换到最后一个标签页&#xA;:tabm [N] 把当前tab移动到第N个tab之后&#xA;&#xA;:e file 把file加载到新的缓冲区中&#xA;:bn 打开当前buffer的下一个buffer&#xA;:bp 打开当前buffer的前一个buffer&#xA;:b”num” 打开指定的buffer，”num”指的是buffer开始的那个数字，比如上图，我想打开list_audit.erb，输入:b7就ok了&#xA;:bd 删除缓冲区(关闭文件)&#xA;&#xA;:sp fn 分割窗口，并将fn加载到新的窗口中&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1 id=&#34;退出编辑器&#34;&gt;退出编辑器&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;:w 将缓冲区写入文件，即保存修改&#xA;:wq 保存修改并退出&#xA;:x 保存修改并退出&#xA;:q 退出，如果对缓冲区进行过修改，则会提示&#xA;:q! 强制退出，放弃修改&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1 id=&#34;查找替换&#34;&gt;查找替换&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;/pattern 向后搜索字符串pattern&#xA;?pattern 向前搜索字符串pattern&#xA;n 下一个匹配(如果是/搜索，则是向下的下一个，?搜索则是向上的下一个)&#xA;N 上一个匹配(同上)&#xA;:%s/old/new/g 搜索整个文件，将所有的old替换为new&#xA;:%s/old/new/gc 搜索整个文件，将所有的old替换为new，每次都要你确认是否替换&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1 id=&#34;复制粘贴&#34;&gt;复制粘贴&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;dd 删除光标所在行&#xA;dw 删除一个字(word)&#xA;x 删除当前字符&#xA;X 删除前一个字符&#xA;D 删除到行末&#xA;yy 复制一行，此命令前可跟数字，标识复制多行，如6yy，表示从当前行开始复制6行&#xA;yw 复制一个字&#xA;y$ 复制到行末&#xA;p 粘贴粘贴板的内容到当前行的下面&#xA;P 粘贴粘贴板的内容到当前行的上面&#xA;]p 有缩进的粘贴，vim会自动调节代码的缩进&#xA;“a 将内容放入/存入a寄存器，可以支持多粘贴板&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;附：比如常用的一个寄存器就是系统寄存器，名称为+，所以从系统粘贴板粘贴到vim中的命令为”+p,注意此处的+不表示操作符，二十一个寄存器。&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;移动光标&#34;&gt;移动光标&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;在vim中移动光标跟其他的编辑器中有很大的区别，不过一旦学会了，就会飞速的在文本中移动了。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;h,j,k,l 上，下，左，右&#xA;ctrl-f 上翻一页&#xA;ctrl-b 下翻一页&#xA;% 跳到与当前括号匹配的括号处，如当前在{，则跳转到与之匹配的}处&#xA;w 跳到下一个字首，按标点或单词分割&#xA;W 跳到下一个字首，长跳，如end-of-line被认为是一个字&#xA;e 跳到下一个字尾&#xA;E 跳到下一个字尾，长跳&#xA;b 跳到上一个字&#xA;B 跳到上一个字，长跳&#xA;0 跳至行首，不管有无缩进，就是跳到第0个字符&#xA;^ 跳至行首的第一个字符&#xA;$ 跳至行尾&#xA;gg 跳至文件的第一行&#xA;gd 跳至当前光标所在的变量的声明处&#xA;[N]G 跳到第N行，如0G，就等价于gg，100G就是第100行&#xA;fx 在当前行中找x字符，找到了就跳转至&#xA;; 重复上一个f命令，而不用重复的输入fx&#xA;tx 与fx类似，但是只是跳转到x的前一个字符处&#xA;Fx 跟fx的方向相反&#xA;),( 跳转到上/下一个语句&#xA;* 查找光标所在处的单词，向下查找&#xA;# 查找光标所在处的单词，向上查找&#xA;`. 跳转至上次编辑位置&#xA;在屏幕上移动&#xA;&#xA;H 移动光标到当前屏幕上最上边的一行&#xA;M 移动光标到当前屏幕上中间的一行&#xA;L 移动光标到当前屏幕上最下边的一行&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1 id=&#34;书签&#34;&gt;书签&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;ma 把当前位置存成标签a&#xA;`a 跳转到标签a处&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1 id=&#34;编辑&#34;&gt;编辑&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;r 替换一个字符&#xA;J 将下一行和当前行连接为一行&#xA;cc 删除当前行并进入编辑模式&#xA;cw 删除当前字，并进入编辑模式&#xA;c$ 擦除从当前位置至行末的内容，并进入编辑模式&#xA;s 删除当前字符并进入编辑模式&#xA;S 删除光标所在行并进入编辑模式&#xA;xp 交换当前字符和下一个字符&#xA;u 撤销&#xA;ctrl+r 重做&#xA;. 重复上一个编辑命令&#xA;~ 切换大小写，当前字符&#xA;g~iw 切换当前字的大小写&#xA;gUiw 将当前字变成大写&#xA;guiw 将当前字变成小写&#xA;&amp;gt;&amp;gt; 将当前行右移一个单位&#xA;&amp;lt;&amp;lt; 将当前行左移一个单位(一个tab符)&#xA;== 自动缩进当前行&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1 id=&#34;插入模式&#34;&gt;插入模式&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;i 从当前光标处进入插入模式&#xA;I 进入插入模式，并置光标于行首&#xA;a 追加模式，置光标于当前光标之后&#xA;A 追加模式，置光标于行末&#xA;o 在当前行之下新加一行，并进入插入模式&#xA;O 在当前行之上新加一行，并进入插入模式&#xA;Esc 退出插入模式&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1 id=&#34;可视模式&#34;&gt;可视模式&lt;/h1&gt;&#xA;&#xA;&lt;h2 id=&#34;标记文本&#34;&gt;标记文本&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;v 进入可视模式，单字符模式&#xA;V 进入可视模式，行模式&#xA;ctrl+v 进入可视模式，列模式，类似于UE的列模式&#xA;o 跳转光标到选中块的另一个端点&#xA;U 将选中块中的内容转成大写&#xA;O 跳转光标到块的另一个端点&#xA;aw 选中一个字&#xA;ab 选中括号中的所有内容，包括括号本身&#xA;aB 选中{}括号中的所有内容&#xA;ib 选中括号中的内容，不含括号&#xA;iB 选中{}中的内容，不含{}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2 id=&#34;对标记进行动作&#34;&gt;对标记进行动作&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; 块右移&#xA;&amp;lt; 块左移&#xA;y 复制块&#xA;d 删除块&#xA;~ 切换块中内容的大小写&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1 id=&#34;窗口命令&#34;&gt;窗口命令&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;ctrl+w s 水平分割窗口&#xA;ctrl+w w 切换窗口&#xA;ctrl+w q 退出当前窗口(由于同时有多个文件，此命令不会影响其他窗口)&#xA;ctrl+w v 垂直分割窗口&#xA;CTRL-W = 使得所有窗口 (几乎) 等宽、等高，但当前窗口使用 ‘winheight’ 和 ‘winwidth’。&#xA;&#xA;:res[ize] -N&#xA;CTRL-W – 使得当前窗口高度减 N (默认值是 1)。如果在 ‘vertical’ 之后使用，则使得宽度减 N。&#xA;&#xA;:res[ize] +N&#xA;CTRL-W + 使得当前窗口高度加 N (默认值是 1)。如果在 ‘vertical’ 之后使用，则使得宽度加 N。&#xA;&#xA;:res[ize] [N]&#xA;CTRL-W CTRL-_&#xA;CTRL-W _ 设置当前窗口的高度为 N (默认值为最大可能高度)。&#xA;&#xA;:vertical res[ize] [N]&#xA;CTRL-W | 设置当前窗口的宽度为 N (默认值为最大可能宽度)。&#xA;&#xA;z{nr}&amp;lt;CR&amp;gt; 设置当前窗口的高度为 {nr}。&#xA;&#xA;CTRL-W &amp;lt; 使得当前窗口宽度减 N (默认值是 1)。&#xA;CTRL-W &amp;gt; 使得当前窗口宽度加 N (默认值是 1)。&#xA;&#xA;&amp;lt;整个窗口的移动&amp;gt;&#xA;CTRL-W-H 将窗口移到最左边&#xA;CTRL-W-L 将窗口移到最右边&#xA;CTRL-W-J 将窗口移到底端&#xA;CTRL-W-K 将窗口移到顶端&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
      <pubDate>Tue, 25 Oct 2016 03:32:01 +0000</pubDate>
    </item>
  </channel>
</rss>